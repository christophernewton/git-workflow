{"version":3,"sources":["node_modules/@gitgraph/js/lib/gitgraph.umd.js","git2.js","git3.js","index.js","node_modules/parcel-bundler/src/builtins/hmr-runtime.js"],"names":["graphContainer","document","getElementById","Revium","TemplateName","Metro","colors","branch","lineWidth","spacing","label","font","displayAuthor","commit","dot","size","strokeColor","strokeWidth","message","gitgraph","template","master","staging","dev","feature1","merge","hotfix","OVERLAY_ID","OldModule","module","bundle","Module","moduleName","call","hot","data","hotData","_acceptCallbacks","_disposeCallbacks","accept","fn","push","dispose","checkedAssets","assetsToAccept","parent","isParcelRequire","WebSocket","hostname","location","protocol","ws","onmessage","event","JSON","parse","type","handled","assets","forEach","asset","isNew","didAccept","hmrAcceptCheck","global","parcelRequire","id","every","generated","js","console","clear","hmrApply","v","hmrAcceptRun","window","reload","close","onclose","log","removeErrorOverlay","error","stack","overlay","createErrorOverlay","body","appendChild","remove","createElement","stackTrace","innerText","innerHTML","getParents","modules","parents","k","d","dep","Array","isArray","length","concat","Function","deps","cached","cache","some","cb"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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","file":"gitgraph.e31bb0bc.js","sourceRoot":"..","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = global || self, factory(global.GitgraphJS = {}));\n}(this, function (exports) { 'use strict';\n\n\tvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\tfunction unwrapExports (x) {\n\t\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n\t}\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tvar mode = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar Mode;\n\t(function (Mode) {\n\t    Mode[\"Compact\"] = \"compact\";\n\t})(Mode || (Mode = {}));\n\texports.Mode = Mode;\n\n\t});\n\n\tunwrapExports(mode);\n\tvar mode_1 = mode.Mode;\n\n\tvar orientation = createCommonjsModule(function (module, exports) {\n\t// Extracted from `gitgraph.ts` because it caused `utils` tests to fail\n\t// because of circular dependency between `utils` and `template`.\n\t// It's not clear why (the circular dependency still exist) but `Orientation`\n\t// was the only one causing issue. Maybe because it's an enum?\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar Orientation;\n\t(function (Orientation) {\n\t    Orientation[\"VerticalReverse\"] = \"vertical-reverse\";\n\t    Orientation[\"Horizontal\"] = \"horizontal\";\n\t    Orientation[\"HorizontalReverse\"] = \"horizontal-reverse\";\n\t})(Orientation = exports.Orientation || (exports.Orientation = {}));\n\n\t});\n\n\tunwrapExports(orientation);\n\tvar orientation_1 = orientation.Orientation;\n\n\tvar utils = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\t/**\n\t * Provide a default value to a boolean.\n\t * @param value\n\t * @param defaultValue\n\t */\n\tfunction booleanOptionOr(value, defaultValue) {\n\t    return typeof value === \"boolean\" ? value : defaultValue;\n\t}\n\texports.booleanOptionOr = booleanOptionOr;\n\t/**\n\t * Provide a default value to a number.\n\t * @param value\n\t * @param defaultValue\n\t */\n\tfunction numberOptionOr(value, defaultValue) {\n\t    return typeof value === \"number\" ? value : defaultValue;\n\t}\n\texports.numberOptionOr = numberOptionOr;\n\t/**\n\t * Creates an object composed of the picked object properties.\n\t * @param obj The source object\n\t * @param paths The property paths to pick\n\t */\n\tfunction pick(obj, paths) {\n\t    return Object.assign({}, paths.reduce((mem, key) => (Object.assign({}, mem, { [key]: obj[key] })), {}));\n\t}\n\texports.pick = pick;\n\t/**\n\t * Print a light version of commits into the console.\n\t * @param commits List of commits\n\t * @param paths The property paths to pick\n\t */\n\tfunction debug(commits, paths) {\n\t    // tslint:disable-next-line:no-console\n\t    console.log(JSON.stringify(commits.map((commit) => pick(commit, paths)), null, 2));\n\t}\n\texports.debug = debug;\n\t/**\n\t * Return true if is undefined.\n\t *\n\t * @param obj\n\t */\n\tfunction isUndefined(obj) {\n\t    return obj === undefined;\n\t}\n\texports.isUndefined = isUndefined;\n\t/**\n\t * Return a version of the object without any undefined keys.\n\t *\n\t * @param obj\n\t */\n\tfunction withoutUndefinedKeys(obj = {}) {\n\t    return Object.keys(obj).reduce((mem, key) => isUndefined(obj[key]) ? mem : Object.assign({}, mem, { [key]: obj[key] }), {});\n\t}\n\texports.withoutUndefinedKeys = withoutUndefinedKeys;\n\t/**\n\t * Return a string ready to use in `svg.path.d` to draw an arrow from params.\n\t *\n\t * @param graph Graph context\n\t * @param parent Parent commit of the target commit\n\t * @param commit Target commit\n\t */\n\tfunction arrowSvgPath(graph, parent, commit) {\n\t    const commitRadius = commit.style.dot.size;\n\t    const size = graph.template.arrow.size;\n\t    const h = commitRadius + graph.template.arrow.offset;\n\t    // Delta between left & right (radian)\n\t    const delta = Math.PI / 7;\n\t    // Alpha angle between parent & commit (radian)\n\t    const alpha = getAlpha(graph, parent, commit);\n\t    // Top\n\t    const x1 = h * Math.cos(alpha);\n\t    const y1 = h * Math.sin(alpha);\n\t    // Bottom right\n\t    const x2 = (h + size) * Math.cos(alpha - delta);\n\t    const y2 = (h + size) * Math.sin(alpha - delta);\n\t    // Bottom center\n\t    const x3 = (h + size / 2) * Math.cos(alpha);\n\t    const y3 = (h + size / 2) * Math.sin(alpha);\n\t    // Bottom left\n\t    const x4 = (h + size) * Math.cos(alpha + delta);\n\t    const y4 = (h + size) * Math.sin(alpha + delta);\n\t    return `M${x1},${y1} L${x2},${y2} Q${x3},${y3} ${x4},${y4} L${x4},${y4}`;\n\t}\n\texports.arrowSvgPath = arrowSvgPath;\n\tfunction getAlpha(graph, parent, commit) {\n\t    const deltaX = parent.x - commit.x;\n\t    const deltaY = parent.y - commit.y;\n\t    const commitSpacing = graph.template.commit.spacing;\n\t    let alphaY;\n\t    let alphaX;\n\t    // Angle usually start from previous commit Y position:\n\t    //\n\t    // o\n\t    // ↑ ↖ ︎\n\t    // o  |  <-- path is straight until last commit Y position\n\t    // ↑  o\n\t    // | ↗︎\n\t    // o\n\t    //\n\t    // So we can to default to commit spacing.\n\t    // For horizontal orientation => same with commit X position.\n\t    switch (graph.orientation) {\n\t        case orientation.Orientation.Horizontal:\n\t            alphaY = deltaY;\n\t            alphaX = -commitSpacing;\n\t            break;\n\t        case orientation.Orientation.HorizontalReverse:\n\t            alphaY = deltaY;\n\t            alphaX = commitSpacing;\n\t            break;\n\t        case orientation.Orientation.VerticalReverse:\n\t            alphaY = -commitSpacing;\n\t            alphaX = deltaX;\n\t            break;\n\t        default:\n\t            alphaY = commitSpacing;\n\t            alphaX = deltaX;\n\t            break;\n\t    }\n\t    // If commit is distant from its parent, there should be no angle.\n\t    //\n\t    //    o ︎\n\t    //    ↑  <-- arrow is like previous commit was on same X position\n\t    // o  |\n\t    // | /\n\t    // o\n\t    //\n\t    // For horizontal orientation => same with commit Y position.\n\t    if (graph.isVertical) {\n\t        if (Math.abs(deltaY) > commitSpacing)\n\t            alphaX = 0;\n\t    }\n\t    else {\n\t        if (Math.abs(deltaX) > commitSpacing)\n\t            alphaY = 0;\n\t    }\n\t    if (graph.reverseArrow) {\n\t        alphaY *= -1;\n\t        alphaX *= -1;\n\t    }\n\t    return Math.atan2(alphaY, alphaX);\n\t}\n\n\t});\n\n\tunwrapExports(utils);\n\tvar utils_1 = utils.booleanOptionOr;\n\tvar utils_2 = utils.numberOptionOr;\n\tvar utils_3 = utils.pick;\n\tvar utils_4 = utils.debug;\n\tvar utils_5 = utils.isUndefined;\n\tvar utils_6 = utils.withoutUndefinedKeys;\n\tvar utils_7 = utils.arrowSvgPath;\n\n\tvar template = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\t/**\n\t * Branch merge style enum\n\t */\n\tvar MergeStyle;\n\t(function (MergeStyle) {\n\t    MergeStyle[\"Bezier\"] = \"bezier\";\n\t    MergeStyle[\"Straight\"] = \"straight\";\n\t})(MergeStyle || (MergeStyle = {}));\n\texports.MergeStyle = MergeStyle;\n\texports.DEFAULT_FONT = \"normal 12pt Calibri\";\n\t/**\n\t * Gitgraph template\n\t *\n\t * Set of design rules for the rendering.\n\t */\n\tclass Template {\n\t    constructor(options) {\n\t        // Options\n\t        options.branch = options.branch || {};\n\t        options.branch.label = options.branch.label || {};\n\t        options.arrow = options.arrow || {};\n\t        options.commit = options.commit || {};\n\t        options.commit.dot = options.commit.dot || {};\n\t        options.commit.message = options.commit.message || {};\n\t        // One color per column\n\t        this.colors = options.colors || [\"#000000\"];\n\t        // Branch style\n\t        this.branch = {\n\t            color: options.branch.color,\n\t            lineWidth: options.branch.lineWidth || 2,\n\t            mergeStyle: options.branch.mergeStyle || MergeStyle.Bezier,\n\t            spacing: utils.numberOptionOr(options.branch.spacing, 20),\n\t            label: {\n\t                display: utils.booleanOptionOr(options.branch.label.display, true),\n\t                color: options.branch.label.color || options.commit.color,\n\t                strokeColor: options.branch.label.strokeColor || options.commit.color,\n\t                bgColor: options.branch.label.bgColor || \"white\",\n\t                font: options.branch.label.font ||\n\t                    options.commit.message.font ||\n\t                    exports.DEFAULT_FONT,\n\t                borderRadius: utils.numberOptionOr(options.branch.label.borderRadius, 10),\n\t            },\n\t        };\n\t        // Arrow style\n\t        this.arrow = {\n\t            size: options.arrow.size || null,\n\t            color: options.arrow.color || null,\n\t            offset: options.arrow.offset || 2,\n\t        };\n\t        // Commit style\n\t        this.commit = {\n\t            color: options.commit.color,\n\t            spacing: utils.numberOptionOr(options.commit.spacing, 25),\n\t            hasTooltipInCompactMode: utils.booleanOptionOr(options.commit.hasTooltipInCompactMode, true),\n\t            dot: {\n\t                color: options.commit.dot.color || options.commit.color,\n\t                size: options.commit.dot.size || 3,\n\t                strokeWidth: utils.numberOptionOr(options.commit.dot.strokeWidth, 0),\n\t                strokeColor: options.commit.dot.strokeColor,\n\t                font: options.commit.dot.font ||\n\t                    options.commit.message.font ||\n\t                    \"normal 10pt Calibri\",\n\t            },\n\t            message: {\n\t                display: utils.booleanOptionOr(options.commit.message.display, true),\n\t                displayAuthor: utils.booleanOptionOr(options.commit.message.displayAuthor, true),\n\t                displayHash: utils.booleanOptionOr(options.commit.message.displayHash, true),\n\t                color: options.commit.message.color || options.commit.color,\n\t                font: options.commit.message.font || exports.DEFAULT_FONT,\n\t            },\n\t        };\n\t        // Tag style\n\t        // This one is computed in the Tag instance. It needs Commit style\n\t        // that is partially computed at runtime (for colors).\n\t        this.tag = options.tag || {};\n\t    }\n\t}\n\texports.Template = Template;\n\t/**\n\t * Black arrow template\n\t */\n\tconst blackArrowTemplate = new Template({\n\t    colors: [\"#6963FF\", \"#47E8D4\", \"#6BDB52\", \"#E84BA5\", \"#FFA657\"],\n\t    branch: {\n\t        color: \"#000000\",\n\t        lineWidth: 4,\n\t        spacing: 50,\n\t        mergeStyle: MergeStyle.Straight,\n\t    },\n\t    commit: {\n\t        spacing: 60,\n\t        dot: {\n\t            size: 16,\n\t            strokeColor: \"#000000\",\n\t            strokeWidth: 4,\n\t        },\n\t        message: {\n\t            color: \"black\",\n\t        },\n\t    },\n\t    arrow: {\n\t        size: 16,\n\t        offset: -1.5,\n\t    },\n\t});\n\texports.blackArrowTemplate = blackArrowTemplate;\n\t/**\n\t * Metro template\n\t */\n\tconst metroTemplate = new Template({\n\t    colors: [\"#979797\", \"#008fb5\", \"#f1c109\"],\n\t    branch: {\n\t        lineWidth: 10,\n\t        spacing: 50,\n\t    },\n\t    commit: {\n\t        spacing: 80,\n\t        dot: {\n\t            size: 14,\n\t        },\n\t        message: {\n\t            font: \"normal 14pt Arial\",\n\t        },\n\t    },\n\t});\n\texports.metroTemplate = metroTemplate;\n\tvar TemplateName;\n\t(function (TemplateName) {\n\t    TemplateName[\"Metro\"] = \"metro\";\n\t    TemplateName[\"BlackArrow\"] = \"blackarrow\";\n\t})(TemplateName || (TemplateName = {}));\n\texports.TemplateName = TemplateName;\n\t/**\n\t * Extend an existing template with new options.\n\t *\n\t * @param selectedTemplate Template to extend\n\t * @param options Template options\n\t */\n\tfunction templateExtend(selectedTemplate, options) {\n\t    const template = getTemplate(selectedTemplate);\n\t    if (!options.branch)\n\t        options.branch = {};\n\t    if (!options.commit)\n\t        options.commit = {};\n\t    // This is tedious, but it seems acceptable so we don't need lodash\n\t    // as we want to keep bundlesize small.\n\t    return {\n\t        colors: options.colors || template.colors,\n\t        arrow: Object.assign({}, template.arrow, options.arrow),\n\t        branch: Object.assign({}, template.branch, options.branch, { label: Object.assign({}, template.branch.label, options.branch.label) }),\n\t        commit: Object.assign({}, template.commit, options.commit, { dot: Object.assign({}, template.commit.dot, options.commit.dot), message: Object.assign({}, template.commit.message, options.commit.message) }),\n\t        tag: Object.assign({}, template.tag, options.tag),\n\t    };\n\t}\n\texports.templateExtend = templateExtend;\n\t/**\n\t * Resolve the template to use regarding given `template` value.\n\t *\n\t * @param template Selected template name, or instance.\n\t */\n\tfunction getTemplate(template) {\n\t    if (!template)\n\t        return metroTemplate;\n\t    if (typeof template === \"string\") {\n\t        return {\n\t            [TemplateName.BlackArrow]: blackArrowTemplate,\n\t            [TemplateName.Metro]: metroTemplate,\n\t        }[template];\n\t    }\n\t    return template;\n\t}\n\texports.getTemplate = getTemplate;\n\n\t});\n\n\tunwrapExports(template);\n\tvar template_1 = template.MergeStyle;\n\tvar template_2 = template.DEFAULT_FONT;\n\tvar template_3 = template.Template;\n\tvar template_4 = template.blackArrowTemplate;\n\tvar template_5 = template.metroTemplate;\n\tvar template_6 = template.TemplateName;\n\tvar template_7 = template.templateExtend;\n\tvar template_8 = template.getTemplate;\n\n\tvar tag = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\tclass Tag {\n\t    constructor(name, style, render, commitStyle) {\n\t        this.name = name;\n\t        this.tagStyle = style;\n\t        this.commitStyle = commitStyle;\n\t        this.render = render;\n\t    }\n\t    /**\n\t     * Style\n\t     */\n\t    get style() {\n\t        return {\n\t            strokeColor: this.tagStyle.strokeColor || this.commitStyle.color,\n\t            bgColor: this.tagStyle.bgColor || this.commitStyle.color,\n\t            color: this.tagStyle.color || \"white\",\n\t            font: this.tagStyle.font || this.commitStyle.message.font || template.DEFAULT_FONT,\n\t            borderRadius: utils.numberOptionOr(this.tagStyle.borderRadius, 10),\n\t            pointerWidth: utils.numberOptionOr(this.tagStyle.pointerWidth, 12),\n\t        };\n\t    }\n\t}\n\texports.Tag = Tag;\n\n\t});\n\n\tunwrapExports(tag);\n\tvar tag_1 = tag.Tag;\n\n\tvar commit = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\t/**\n\t * Generate a random hash.\n\t *\n\t * @return hex string with 40 chars\n\t */\n\tconst getRandomHash = () => (Math.random()\n\t    .toString(16)\n\t    .substring(3) +\n\t    Math.random()\n\t        .toString(16)\n\t        .substring(3) +\n\t    Math.random()\n\t        .toString(16)\n\t        .substring(3) +\n\t    Math.random()\n\t        .toString(16)\n\t        .substring(3)).substring(0, 40);\n\tclass Commit {\n\t    constructor(options) {\n\t        /**\n\t         * Ref names\n\t         */\n\t        this.refs = [];\n\t        /**\n\t         * Commit x position\n\t         */\n\t        this.x = 0;\n\t        /**\n\t         * Commit y position\n\t         */\n\t        this.y = 0;\n\t        // Set author & committer\n\t        let name, email;\n\t        try {\n\t            [, name, email] = options.author.match(/(.*) <(.*)>/);\n\t        }\n\t        catch (e) {\n\t            [name, email] = [options.author, \"\"];\n\t        }\n\t        this.author = { name, email, timestamp: Date.now() };\n\t        this.committer = { name, email, timestamp: Date.now() };\n\t        // Set commit message\n\t        this.subject = options.subject;\n\t        this.body = options.body || \"\";\n\t        // Set commit hash\n\t        this.hash = options.hash || getRandomHash();\n\t        this.hashAbbrev = this.hash.substring(0, 7);\n\t        // Set parent hash\n\t        this.parents = options.parents ? options.parents : [];\n\t        this.parentsAbbrev = this.parents.map((commit) => commit.substring(0, 7));\n\t        // Set style\n\t        this.style = Object.assign({}, options.style, { message: Object.assign({}, options.style.message), dot: Object.assign({}, options.style.dot) });\n\t        this.dotText = options.dotText;\n\t        // Set callbacks\n\t        this.onClick = () => (options.onClick ? options.onClick(this) : undefined);\n\t        this.onMessageClick = () => options.onMessageClick ? options.onMessageClick(this) : undefined;\n\t        this.onMouseOver = () => options.onMouseOver ? options.onMouseOver(this) : undefined;\n\t        this.onMouseOut = () => options.onMouseOut ? options.onMouseOut(this) : undefined;\n\t        // Set custom renders\n\t        this.renderDot = options.renderDot;\n\t        this.renderMessage = options.renderMessage;\n\t        this.renderTooltip = options.renderTooltip;\n\t    }\n\t    /**\n\t     * Message\n\t     */\n\t    get message() {\n\t        let message = \"\";\n\t        if (this.style.message.displayHash) {\n\t            message += `${this.hashAbbrev} `;\n\t        }\n\t        message += this.subject;\n\t        if (this.style.message.displayAuthor) {\n\t            message += ` - ${this.author.name} <${this.author.email}>`;\n\t        }\n\t        return message;\n\t    }\n\t    /**\n\t     * Branch that should be rendered\n\t     */\n\t    get branchToDisplay() {\n\t        return this.branches ? this.branches[0] : \"\";\n\t    }\n\t    setRefs(refs) {\n\t        this.refs = refs.getNames(this.hash);\n\t        return this;\n\t    }\n\t    setTags(tags, getTagStyle, getTagRender) {\n\t        this.tags = tags\n\t            .getNames(this.hash)\n\t            .map((name) => new tag.Tag(name, getTagStyle(name), getTagRender(name), this.style));\n\t        return this;\n\t    }\n\t    setBranches(branches) {\n\t        this.branches = branches;\n\t        return this;\n\t    }\n\t    setPosition({ x, y }) {\n\t        this.x = x;\n\t        this.y = y;\n\t        return this;\n\t    }\n\t    withDefaultColor(color) {\n\t        const newStyle = Object.assign({}, this.style, { dot: Object.assign({}, this.style.dot), message: Object.assign({}, this.style.message) });\n\t        if (!newStyle.color)\n\t            newStyle.color = color;\n\t        if (!newStyle.dot.color)\n\t            newStyle.dot.color = color;\n\t        if (!newStyle.message.color)\n\t            newStyle.message.color = color;\n\t        const commit = this.cloneCommit();\n\t        commit.style = newStyle;\n\t        return commit;\n\t    }\n\t    /**\n\t     * Ideally, we want Commit to be a [Value Object](https://martinfowler.com/bliki/ValueObject.html).\n\t     * We started with a mutable class. So we'll refactor that little by little.\n\t     * This private function is a helper to create a new Commit from existing one.\n\t     */\n\t    cloneCommit() {\n\t        const commit = new Commit({\n\t            author: `${this.author.name} <${this.author.email}>`,\n\t            subject: this.subject,\n\t            style: this.style,\n\t            body: this.body,\n\t            hash: this.hash,\n\t            parents: this.parents,\n\t            dotText: this.dotText,\n\t            onClick: this.onClick,\n\t            onMessageClick: this.onMessageClick,\n\t            onMouseOver: this.onMouseOver,\n\t            onMouseOut: this.onMouseOut,\n\t            renderDot: this.renderDot,\n\t            renderMessage: this.renderMessage,\n\t            renderTooltip: this.renderTooltip,\n\t        });\n\t        commit.refs = this.refs;\n\t        commit.branches = this.branches;\n\t        commit.tags = this.tags;\n\t        commit.x = this.x;\n\t        commit.y = this.y;\n\t        return commit;\n\t    }\n\t}\n\texports.Commit = Commit;\n\n\t});\n\n\tunwrapExports(commit);\n\tvar commit_1 = commit.Commit;\n\n\tvar branchUserApi = createCommonjsModule(function (module, exports) {\n\tvar __rest = (commonjsGlobal && commonjsGlobal.__rest) || function (s, e) {\n\t    var t = {};\n\t    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n\t        t[p] = s[p];\n\t    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n\t        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n\t            t[p[i]] = s[p[i]];\n\t    return t;\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\tclass BranchUserApi {\n\t    // tslint:enable:variable-name\n\t    constructor(branch, graph, onGraphUpdate) {\n\t        this._branch = branch;\n\t        this.name = branch.name;\n\t        this._graph = graph;\n\t        this._onGraphUpdate = onGraphUpdate;\n\t    }\n\t    branch(args) {\n\t        const options = typeof args === \"string\" ? { name: args } : args;\n\t        options.from = this;\n\t        return this._graph.createBranch(options).getUserApi();\n\t    }\n\t    commit(options) {\n\t        // Deal with shorter syntax\n\t        if (typeof options === \"string\")\n\t            options = { subject: options };\n\t        if (!options)\n\t            options = {};\n\t        this._commitWithParents(options, []);\n\t        this._onGraphUpdate();\n\t        return this;\n\t    }\n\t    merge(...args) {\n\t        let options = args[0];\n\t        if (!isBranchMergeOptions(options)) {\n\t            options = {\n\t                branch: args[0],\n\t                fastForward: false,\n\t                commitOptions: { subject: args[1] },\n\t            };\n\t        }\n\t        const { branch, fastForward, commitOptions, } = options;\n\t        const branchName = typeof branch === \"string\" ? branch : branch.name;\n\t        const branchLastCommitHash = this._graph.refs.getCommit(branchName);\n\t        if (!branchLastCommitHash) {\n\t            throw new Error(`The branch called \"${branchName}\" is unknown`);\n\t        }\n\t        let canFastForward = false;\n\t        const lastCommitHash = this._graph.refs.getCommit(this._branch.name);\n\t        if (lastCommitHash) {\n\t            canFastForward = this._areCommitsConnected(lastCommitHash, branchLastCommitHash);\n\t        }\n\t        else {\n\t            canFastForward = false;\n\t        }\n\t        if (fastForward && canFastForward) {\n\t            this._fastForwardTo(branchLastCommitHash);\n\t        }\n\t        else {\n\t            this._commitWithParents(Object.assign({}, commitOptions, { subject: (commitOptions && commitOptions.subject) ||\n\t                    `Merge branch ${branchName}` }), [branchLastCommitHash]);\n\t        }\n\t        this._onGraphUpdate();\n\t        return this;\n\t    }\n\t    tag(options) {\n\t        if (typeof options === \"string\") {\n\t            this._graph.getUserApi().tag({ name: options, ref: this._branch.name });\n\t        }\n\t        else {\n\t            this._graph.getUserApi().tag(Object.assign({}, options, { ref: this._branch.name }));\n\t        }\n\t        return this;\n\t    }\n\t    /**\n\t     * Checkout onto this branch.\n\t     */\n\t    checkout() {\n\t        this._graph.currentBranch = this._branch;\n\t        return this;\n\t    }\n\t    // tslint:disable:variable-name - Prefix `_` = explicitly private for JS users\n\t    _commitWithParents(options, parents) {\n\t        const parentOnSameBranch = this._graph.refs.getCommit(this._branch.name);\n\t        if (parentOnSameBranch) {\n\t            parents.unshift(parentOnSameBranch);\n\t        }\n\t        else if (this._branch.parentCommitHash) {\n\t            parents.unshift(this._branch.parentCommitHash);\n\t        }\n\t        const { tag } = options, commitOptions = __rest(options, [\"tag\"]);\n\t        const commit$1 = new commit.Commit(Object.assign({ hash: this._graph.generateCommitHash(), author: this._branch.commitDefaultOptions.author || this._graph.author, subject: this._branch.commitDefaultOptions.subject ||\n\t                this._graph.commitMessage }, commitOptions, { parents, style: this._getCommitStyle(options.style) }));\n\t        if (parentOnSameBranch) {\n\t            // Take all the refs from the parent\n\t            const parentRefs = this._graph.refs.getNames(parentOnSameBranch);\n\t            parentRefs.forEach((ref) => this._graph.refs.set(ref, commit$1.hash));\n\t        }\n\t        else {\n\t            // Set the branch ref\n\t            this._graph.refs.set(this._branch.name, commit$1.hash);\n\t        }\n\t        // Add the new commit\n\t        this._graph.commits.push(commit$1);\n\t        // Move HEAD on the last commit\n\t        this.checkout();\n\t        this._graph.refs.set(\"HEAD\", commit$1.hash);\n\t        // Add a tag to the commit if `option.tag` is provide\n\t        if (tag)\n\t            this.tag(tag);\n\t    }\n\t    _areCommitsConnected(parentCommitHash, childCommitHash) {\n\t        const childCommit = this._graph.commits.find(({ hash }) => childCommitHash === hash);\n\t        if (!childCommit)\n\t            return false;\n\t        const isFirstCommitOfGraph = childCommit.parents.length === 0;\n\t        if (isFirstCommitOfGraph)\n\t            return false;\n\t        if (childCommit.parents.includes(parentCommitHash)) {\n\t            return true;\n\t        }\n\t        // `childCommitHash` is not a direct child of `parentCommitHash`.\n\t        // But maybe one of `childCommitHash` parent is.\n\t        return childCommit.parents.some((directParentHash) => this._areCommitsConnected(parentCommitHash, directParentHash));\n\t    }\n\t    _fastForwardTo(commitHash) {\n\t        this._graph.refs.set(this._branch.name, commitHash);\n\t    }\n\t    _getCommitStyle(style = {}) {\n\t        const message = Object.assign({}, utils.withoutUndefinedKeys(this._graph.template.commit.message), utils.withoutUndefinedKeys(this._branch.commitDefaultOptions.style.message), style.message);\n\t        if (this._graph.isHorizontal || this._graph.mode === mode.Mode.Compact) {\n\t            message.display = false;\n\t        }\n\t        return Object.assign({}, utils.withoutUndefinedKeys(this._graph.template.commit), utils.withoutUndefinedKeys(this._branch.commitDefaultOptions.style), style, { message, dot: Object.assign({}, utils.withoutUndefinedKeys(this._graph.template.commit.dot), utils.withoutUndefinedKeys(this._branch.commitDefaultOptions.style.dot), style.dot) });\n\t    }\n\t}\n\texports.BranchUserApi = BranchUserApi;\n\tfunction isBranchMergeOptions(options) {\n\t    return typeof options === \"object\" && !(options instanceof BranchUserApi);\n\t}\n\n\t});\n\n\tunwrapExports(branchUserApi);\n\tvar branchUserApi_1 = branchUserApi.BranchUserApi;\n\n\tvar branch = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\tconst DELETED_BRANCH_NAME = \"\";\n\texports.DELETED_BRANCH_NAME = DELETED_BRANCH_NAME;\n\tclass Branch {\n\t    constructor(options) {\n\t        this.gitgraph = options.gitgraph;\n\t        this.name = options.name;\n\t        this.style = options.style;\n\t        this.parentCommitHash = options.parentCommitHash;\n\t        this.commitDefaultOptions = options.commitDefaultOptions || { style: {} };\n\t        this.onGraphUpdate = options.onGraphUpdate;\n\t        this.renderLabel = options.renderLabel;\n\t    }\n\t    /**\n\t     * Return the API to manipulate Gitgraph branch as a user.\n\t     */\n\t    getUserApi() {\n\t        return new branchUserApi.BranchUserApi(this, this.gitgraph, this.onGraphUpdate);\n\t    }\n\t    /**\n\t     * Return true if branch was deleted.\n\t     */\n\t    isDeleted() {\n\t        return this.name === DELETED_BRANCH_NAME;\n\t    }\n\t}\n\texports.Branch = Branch;\n\tfunction createDeletedBranch(gitgraph, style, onGraphUpdate) {\n\t    return new Branch({\n\t        name: DELETED_BRANCH_NAME,\n\t        gitgraph,\n\t        style,\n\t        onGraphUpdate,\n\t    });\n\t}\n\texports.createDeletedBranch = createDeletedBranch;\n\n\t});\n\n\tunwrapExports(branch);\n\tvar branch_1 = branch.DELETED_BRANCH_NAME;\n\tvar branch_2 = branch.Branch;\n\tvar branch_3 = branch.createDeletedBranch;\n\n\tvar regular = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tclass RegularGraphRows {\n\t    constructor(commits) {\n\t        this.rows = new Map();\n\t        this.maxRowCache = undefined;\n\t        this.computeRowsFromCommits(commits);\n\t    }\n\t    getRowOf(commitHash) {\n\t        return this.rows.get(commitHash) || 0;\n\t    }\n\t    getMaxRow() {\n\t        if (this.maxRowCache === undefined) {\n\t            this.maxRowCache = uniq(Array.from(this.rows.values())).length - 1;\n\t        }\n\t        return this.maxRowCache;\n\t    }\n\t    computeRowsFromCommits(commits) {\n\t        commits.forEach((commit, i) => {\n\t            this.rows.set(commit.hash, i);\n\t        });\n\t        this.maxRowCache = undefined;\n\t    }\n\t}\n\texports.RegularGraphRows = RegularGraphRows;\n\t/**\n\t * Creates a duplicate-free version of an array.\n\t *\n\t * Don't use lodash's `uniq` as it increased bundlesize a lot for such a\n\t * simple function.\n\t * => The way we bundle for browser seems not to work with `lodash-es`.\n\t * => I didn't to get tree-shaking to work with `lodash` (the CommonJS version).\n\t *\n\t * @param array Array of values\n\t */\n\tfunction uniq(array) {\n\t    const set = new Set();\n\t    array.forEach((value) => set.add(value));\n\t    return Array.from(set);\n\t}\n\n\t});\n\n\tunwrapExports(regular);\n\tvar regular_1 = regular.RegularGraphRows;\n\n\tvar compact = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\tclass CompactGraphRows extends regular.RegularGraphRows {\n\t    computeRowsFromCommits(commits) {\n\t        commits.forEach((commit, i) => {\n\t            let newRow = i;\n\t            const isFirstCommit = i === 0;\n\t            if (!isFirstCommit) {\n\t                const parentRow = this.getRowOf(commit.parents[0]);\n\t                const historyParent = commits[i - 1];\n\t                newRow = Math.max(parentRow + 1, this.getRowOf(historyParent.hash));\n\t                const isMergeCommit = commit.parents.length > 1;\n\t                if (isMergeCommit) {\n\t                    // Push commit to next row to avoid collision when the branch in which\n\t                    // the merge happens has more commits than the merged branch.\n\t                    const mergeTargetParentRow = this.getRowOf(commit.parents[1]);\n\t                    if (parentRow < mergeTargetParentRow)\n\t                        newRow++;\n\t                }\n\t            }\n\t            this.rows.set(commit.hash, newRow);\n\t        });\n\t    }\n\t}\n\texports.CompactGraphRows = CompactGraphRows;\n\n\t});\n\n\tunwrapExports(compact);\n\tvar compact_1 = compact.CompactGraphRows;\n\n\tvar graphRows = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\texports.GraphRows = regular.RegularGraphRows;\n\tfunction createGraphRows(mode$1, commits) {\n\t    return mode$1 === mode.Mode.Compact\n\t        ? new compact.CompactGraphRows(commits)\n\t        : new regular.RegularGraphRows(commits);\n\t}\n\texports.createGraphRows = createGraphRows;\n\n\t});\n\n\tunwrapExports(graphRows);\n\tvar graphRows_1 = graphRows.GraphRows;\n\tvar graphRows_2 = graphRows.createGraphRows;\n\n\tvar branchesOrder = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tclass BranchesOrder {\n\t    constructor(commits, colors, compareFunction) {\n\t        this.branches = new Set();\n\t        this.colors = colors;\n\t        commits.forEach((commit) => this.branches.add(commit.branchToDisplay));\n\t        if (compareFunction) {\n\t            this.branches = new Set(Array.from(this.branches).sort(compareFunction));\n\t        }\n\t    }\n\t    /**\n\t     * Return the order of the given branch name.\n\t     *\n\t     * @param branchName Name of the branch\n\t     */\n\t    get(branchName) {\n\t        return Array.from(this.branches).findIndex((branch) => branch === branchName);\n\t    }\n\t    /**\n\t     * Return the color of the given branch.\n\t     *\n\t     * @param branchName Name of the branch\n\t     */\n\t    getColorOf(branchName) {\n\t        return this.colors[this.get(branchName) % this.colors.length];\n\t    }\n\t}\n\texports.BranchesOrder = BranchesOrder;\n\n\t});\n\n\tunwrapExports(branchesOrder);\n\tvar branchesOrder_1 = branchesOrder.BranchesOrder;\n\n\tvar refs = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tclass Refs {\n\t    constructor() {\n\t        this.commitPerName = new Map();\n\t        this.namesPerCommit = new Map();\n\t    }\n\t    /**\n\t     * Set a new reference to a commit hash.\n\t     *\n\t     * @param name Name of the ref (ex: \"master\", \"v1.0\")\n\t     * @param commitHash Commit hash\n\t     */\n\t    set(name, commitHash) {\n\t        const prevCommitHash = this.commitPerName.get(name);\n\t        if (prevCommitHash) {\n\t            this.removeNameFrom(prevCommitHash, name);\n\t        }\n\t        this.addNameTo(commitHash, name);\n\t        this.addCommitTo(name, commitHash);\n\t        return this;\n\t    }\n\t    /**\n\t     * Get the commit hash associated with the given reference name.\n\t     *\n\t     * @param name Name of the ref\n\t     */\n\t    getCommit(name) {\n\t        return this.commitPerName.get(name);\n\t    }\n\t    /**\n\t     * Get the list of reference names associated with given commit hash.\n\t     *\n\t     * @param commitHash Commit hash\n\t     */\n\t    getNames(commitHash) {\n\t        return this.namesPerCommit.get(commitHash) || [];\n\t    }\n\t    /**\n\t     * Get all reference names known.\n\t     */\n\t    getAllNames() {\n\t        return Array.from(this.commitPerName.keys());\n\t    }\n\t    /**\n\t     * Returns true if given commit hash is referenced.\n\t     *\n\t     * @param commitHash Commit hash\n\t     */\n\t    hasCommit(commitHash) {\n\t        return this.namesPerCommit.has(commitHash);\n\t    }\n\t    /**\n\t     * Returns true if given reference name exists.\n\t     *\n\t     * @param name Name of the ref\n\t     */\n\t    hasName(name) {\n\t        return this.commitPerName.has(name);\n\t    }\n\t    removeNameFrom(commitHash, nameToRemove) {\n\t        const names = this.namesPerCommit.get(commitHash) || [];\n\t        this.namesPerCommit.set(commitHash, names.filter((name) => name !== nameToRemove));\n\t    }\n\t    addNameTo(commitHash, nameToAdd) {\n\t        const prevNames = this.namesPerCommit.get(commitHash) || [];\n\t        this.namesPerCommit.set(commitHash, [...prevNames, nameToAdd]);\n\t    }\n\t    addCommitTo(name, commitHashToAdd) {\n\t        this.commitPerName.set(name, commitHashToAdd);\n\t    }\n\t}\n\texports.Refs = Refs;\n\n\t});\n\n\tunwrapExports(refs);\n\tvar refs_1 = refs.Refs;\n\n\tvar branchesPaths = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\t/**\n\t * Calculate branches paths of the graph.\n\t *\n\t * It follows the Command pattern:\n\t * => a class with a single `execute()` public method.\n\t *\n\t * Main benefit is we can split computation in smaller steps without\n\t * passing around parameters (we can rely on private data).\n\t */\n\tclass BranchesPathsCalculator {\n\t    constructor(commits, branches, commitSpacing, isGraphVertical, isGraphReverse, createDeletedBranch) {\n\t        this.branchesPaths = new Map();\n\t        this.commits = commits;\n\t        this.branches = branches;\n\t        this.commitSpacing = commitSpacing;\n\t        this.isGraphVertical = isGraphVertical;\n\t        this.isGraphReverse = isGraphReverse;\n\t        this.createDeletedBranch = createDeletedBranch;\n\t    }\n\t    /**\n\t     * Compute branches paths for graph.\n\t     */\n\t    execute() {\n\t        this.fromCommits();\n\t        this.withMergeCommits();\n\t        return this.smoothBranchesPaths();\n\t    }\n\t    /**\n\t     * Initialize branches paths from calculator's commits.\n\t     */\n\t    fromCommits() {\n\t        this.commits.forEach((commit) => {\n\t            let branch = this.branches.get(commit.branchToDisplay);\n\t            if (!branch) {\n\t                // NB: may not work properly if there are many deleted branches.\n\t                branch = this.getDeletedBranchInPath() || this.createDeletedBranch();\n\t            }\n\t            const path = [];\n\t            const existingBranchPath = this.branchesPaths.get(branch);\n\t            const firstParentCommit = this.commits.find(({ hash }) => hash === commit.parents[0]);\n\t            if (existingBranchPath) {\n\t                path.push(...existingBranchPath);\n\t            }\n\t            else if (firstParentCommit) {\n\t                // Make branch path starts from parent branch (parent commit).\n\t                path.push({ x: firstParentCommit.x, y: firstParentCommit.y });\n\t            }\n\t            path.push({ x: commit.x, y: commit.y });\n\t            this.branchesPaths.set(branch, path);\n\t        });\n\t    }\n\t    /**\n\t     * Insert merge commits points into `branchesPaths`.\n\t     *\n\t     * @example\n\t     *     // Before\n\t     *     [\n\t     *       { x: 0, y: 640 },\n\t     *       { x: 50, y: 560 }\n\t     *     ]\n\t     *\n\t     *     // After\n\t     *     [\n\t     *       { x: 0, y: 640 },\n\t     *       { x: 50, y: 560 },\n\t     *       { x: 50, y: 560, mergeCommit: true }\n\t     *     ]\n\t     */\n\t    withMergeCommits() {\n\t        const mergeCommits = this.commits.filter(({ parents }) => parents.length > 1);\n\t        mergeCommits.forEach((mergeCommit) => {\n\t            const parentOnOriginBranch = this.commits.find(({ hash }) => {\n\t                return hash === mergeCommit.parents[1];\n\t            });\n\t            if (!parentOnOriginBranch)\n\t                return;\n\t            const originBranchName = parentOnOriginBranch.branches\n\t                ? parentOnOriginBranch.branches[0]\n\t                : \"\";\n\t            let branch = this.branches.get(originBranchName);\n\t            if (!branch) {\n\t                branch = this.getDeletedBranchInPath();\n\t                if (!branch) {\n\t                    // Still no branch? That's strange, we shouldn't set anything.\n\t                    return;\n\t                }\n\t            }\n\t            const lastPoints = [...(this.branchesPaths.get(branch) || [])];\n\t            this.branchesPaths.set(branch, [\n\t                ...lastPoints,\n\t                { x: mergeCommit.x, y: mergeCommit.y, mergeCommit: true },\n\t            ]);\n\t        });\n\t    }\n\t    /**\n\t     * Retrieve deleted branch from calculator's branches paths.\n\t     */\n\t    getDeletedBranchInPath() {\n\t        return Array.from(this.branchesPaths.keys()).find((branch) => branch.isDeleted());\n\t    }\n\t    /**\n\t     * Smooth all paths by putting points on each row.\n\t     */\n\t    smoothBranchesPaths() {\n\t        const branchesPaths = new Map();\n\t        this.branchesPaths.forEach((points, branch) => {\n\t            if (points.length <= 1) {\n\t                branchesPaths.set(branch, [points]);\n\t                return;\n\t            }\n\t            // Cut path on each merge commits\n\t            // Coordinate[] -> Coordinate[][]\n\t            if (this.isGraphVertical) {\n\t                points = points.sort((a, b) => (a.y > b.y ? -1 : 1));\n\t            }\n\t            else {\n\t                points = points.sort((a, b) => (a.x > b.x ? 1 : -1));\n\t            }\n\t            if (this.isGraphReverse) {\n\t                points = points.reverse();\n\t            }\n\t            const paths = points.reduce((mem, point, i) => {\n\t                if (point.mergeCommit) {\n\t                    mem[mem.length - 1].push(utils.pick(point, [\"x\", \"y\"]));\n\t                    if (points[i - 1])\n\t                        mem.push([points[i - 1]]);\n\t                }\n\t                else {\n\t                    mem[mem.length - 1].push(point);\n\t                }\n\t                return mem;\n\t            }, [[]]);\n\t            if (this.isGraphReverse) {\n\t                paths.forEach((path) => path.reverse());\n\t            }\n\t            // Add intermediate points on each sub paths\n\t            if (this.isGraphVertical) {\n\t                paths.forEach((subPath) => {\n\t                    if (subPath.length <= 1)\n\t                        return;\n\t                    const firstPoint = subPath[0];\n\t                    const lastPoint = subPath[subPath.length - 1];\n\t                    const column = subPath[1].x;\n\t                    const branchSize = Math.round(Math.abs(firstPoint.y - lastPoint.y) / this.commitSpacing) - 1;\n\t                    const branchPoints = branchSize > 0\n\t                        ? new Array(branchSize).fill(0).map((_, i) => ({\n\t                            x: column,\n\t                            y: subPath[0].y - this.commitSpacing * (i + 1),\n\t                        }))\n\t                        : [];\n\t                    const lastSubPaths = branchesPaths.get(branch) || [];\n\t                    branchesPaths.set(branch, [\n\t                        ...lastSubPaths,\n\t                        [firstPoint, ...branchPoints, lastPoint],\n\t                    ]);\n\t                });\n\t            }\n\t            else {\n\t                paths.forEach((subPath) => {\n\t                    if (subPath.length <= 1)\n\t                        return;\n\t                    const firstPoint = subPath[0];\n\t                    const lastPoint = subPath[subPath.length - 1];\n\t                    const column = subPath[1].y;\n\t                    const branchSize = Math.round(Math.abs(firstPoint.x - lastPoint.x) / this.commitSpacing) - 1;\n\t                    const branchPoints = branchSize > 0\n\t                        ? new Array(branchSize).fill(0).map((_, i) => ({\n\t                            y: column,\n\t                            x: subPath[0].x + this.commitSpacing * (i + 1),\n\t                        }))\n\t                        : [];\n\t                    const lastSubPaths = branchesPaths.get(branch) || [];\n\t                    branchesPaths.set(branch, [\n\t                        ...lastSubPaths,\n\t                        [firstPoint, ...branchPoints, lastPoint],\n\t                    ]);\n\t                });\n\t            }\n\t        });\n\t        return branchesPaths;\n\t    }\n\t}\n\texports.BranchesPathsCalculator = BranchesPathsCalculator;\n\t/**\n\t * Return a string ready to use in `svg.path.d` from coordinates\n\t *\n\t * @param coordinates Collection of coordinates\n\t */\n\tfunction toSvgPath(coordinates, isBezier, isVertical) {\n\t    return coordinates\n\t        .map((path) => \"M\" +\n\t        path\n\t            .map(({ x, y }, i, points) => {\n\t            if (isBezier &&\n\t                points.length > 1 &&\n\t                (i === 1 || i === points.length - 1)) {\n\t                const previous = points[i - 1];\n\t                if (isVertical) {\n\t                    const middleY = (previous.y + y) / 2;\n\t                    return `C ${previous.x} ${middleY} ${x} ${middleY} ${x} ${y}`;\n\t                }\n\t                else {\n\t                    const middleX = (previous.x + x) / 2;\n\t                    return `C ${middleX} ${previous.y} ${middleX} ${y} ${x} ${y}`;\n\t                }\n\t            }\n\t            return `L ${x} ${y}`;\n\t        })\n\t            .join(\" \")\n\t            .slice(1))\n\t        .join(\" \");\n\t}\n\texports.toSvgPath = toSvgPath;\n\n\t});\n\n\tunwrapExports(branchesPaths);\n\tvar branchesPaths_1 = branchesPaths.BranchesPathsCalculator;\n\tvar branchesPaths_2 = branchesPaths.toSvgPath;\n\n\tvar gitgraphUserApi = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\tclass GitgraphUserApi {\n\t    // tslint:enable:variable-name\n\t    constructor(graph, onGraphUpdate) {\n\t        this._graph = graph;\n\t        this._onGraphUpdate = onGraphUpdate;\n\t    }\n\t    /**\n\t     * Clear everything (as `rm -rf .git && git init`).\n\t     */\n\t    clear() {\n\t        this._graph.refs = new refs.Refs();\n\t        this._graph.tags = new refs.Refs();\n\t        this._graph.commits = [];\n\t        this._graph.branches = new Map();\n\t        this._graph.currentBranch = this._graph.createBranch(\"master\");\n\t        this._onGraphUpdate();\n\t        return this;\n\t    }\n\t    commit(options) {\n\t        this._graph.currentBranch.getUserApi().commit(options);\n\t        return this;\n\t    }\n\t    branch(args) {\n\t        return this._graph.createBranch(args).getUserApi();\n\t    }\n\t    tag(...args) {\n\t        // Deal with shorter syntax\n\t        let name;\n\t        let ref;\n\t        let style;\n\t        let render;\n\t        if (typeof args[0] === \"string\") {\n\t            name = args[0];\n\t            ref = args[1];\n\t        }\n\t        else {\n\t            name = args[0].name;\n\t            ref = args[0].ref;\n\t            style = args[0].style;\n\t            render = args[0].render;\n\t        }\n\t        if (!ref) {\n\t            const head = this._graph.refs.getCommit(\"HEAD\");\n\t            if (!head)\n\t                return this;\n\t            ref = head;\n\t        }\n\t        let commitHash;\n\t        if (this._graph.refs.hasCommit(ref)) {\n\t            // `ref` is a `Commit[\"hash\"]`\n\t            commitHash = ref;\n\t        }\n\t        if (this._graph.refs.hasName(ref)) {\n\t            // `ref` is a `Branch[\"name\"]`\n\t            commitHash = this._graph.refs.getCommit(ref);\n\t        }\n\t        if (!commitHash) {\n\t            throw new Error(`The ref \"${ref}\" does not exist`);\n\t        }\n\t        this._graph.tags.set(name, commitHash);\n\t        this._graph.tagStyles[name] = style;\n\t        this._graph.tagRenders[name] = render;\n\t        this._onGraphUpdate();\n\t        return this;\n\t    }\n\t    /**\n\t     * Import a JSON.\n\t     *\n\t     * Data can't be typed since it comes from a JSON.\n\t     * We validate input format and throw early if something is invalid.\n\t     *\n\t     * @experimental\n\t     * @param data JSON from `git2json` output\n\t     */\n\t    import(data) {\n\t        const invalidData = new Error(\"Only `git2json` format is supported for imported data.\");\n\t        // We manually validate input data instead of using a lib like yup.\n\t        // => this is to keep bundlesize small.\n\t        if (!Array.isArray(data)) {\n\t            throw invalidData;\n\t        }\n\t        const areDataValid = data.every((options) => {\n\t            return (typeof options === \"object\" &&\n\t                typeof options.author === \"object\" &&\n\t                Array.isArray(options.refs));\n\t        });\n\t        if (!areDataValid) {\n\t            throw invalidData;\n\t        }\n\t        const commitOptionsList = data\n\t            .map((options) => (Object.assign({}, options, { style: Object.assign({}, this._graph.template.commit), author: `${options.author.name} <${options.author.email}>` })))\n\t            // Git2json outputs is reverse-chronological.\n\t            // We need to commit it chronological order.\n\t            .reverse();\n\t        // Use validated `value`.\n\t        this.clear();\n\t        this._graph.commits = commitOptionsList.map((options) => new commit.Commit(options));\n\t        // Create tags & refs.\n\t        commitOptionsList.forEach(({ refs, hash }) => {\n\t            if (!refs)\n\t                return;\n\t            if (!hash)\n\t                return;\n\t            const TAG_PREFIX = \"tag: \";\n\t            const tags = refs\n\t                .map((ref) => ref.split(TAG_PREFIX))\n\t                .map(([_, tag]) => tag)\n\t                .filter((tag) => typeof tag === \"string\");\n\t            tags.forEach((tag) => this._graph.tags.set(tag, hash));\n\t            refs\n\t                .filter((ref) => !ref.startsWith(TAG_PREFIX))\n\t                .forEach((ref) => this._graph.refs.set(ref, hash));\n\t        });\n\t        // Create branches.\n\t        const branches = this._getBranches();\n\t        this._graph.commits\n\t            .map((commit) => this._withBranches(branches, commit))\n\t            .reduce((mem, commit) => {\n\t            if (!commit.branches)\n\t                return mem;\n\t            commit.branches.forEach((branch) => mem.add(branch));\n\t            return mem;\n\t        }, new Set())\n\t            .forEach((branch) => this.branch(branch));\n\t        this._onGraphUpdate();\n\t        return this;\n\t    }\n\t    // tslint:disable:variable-name - Prefix `_` = explicitly private for JS users\n\t    // TODO: get rid of these duplicated private methods.\n\t    //\n\t    // These belong to Gitgraph. It is duplicated because of `import()`.\n\t    // `import()` should use regular user API instead.\n\t    _withBranches(branches, commit) {\n\t        let commitBranches = Array.from((branches.get(commit.hash) || new Set()).values());\n\t        if (commitBranches.length === 0) {\n\t            // No branch => branch has been deleted.\n\t            commitBranches = [branch.DELETED_BRANCH_NAME];\n\t        }\n\t        return commit.setBranches(commitBranches);\n\t    }\n\t    _getBranches() {\n\t        const result = new Map();\n\t        const queue = [];\n\t        const branches = this._graph.refs\n\t            .getAllNames()\n\t            .filter((name) => name !== \"HEAD\");\n\t        branches.forEach((branch) => {\n\t            const commitHash = this._graph.refs.getCommit(branch);\n\t            if (commitHash) {\n\t                queue.push(commitHash);\n\t            }\n\t            while (queue.length > 0) {\n\t                const currentHash = queue.pop();\n\t                const current = this._graph.commits.find(({ hash }) => hash === currentHash);\n\t                const prevBranches = result.get(currentHash) || new Set();\n\t                prevBranches.add(branch);\n\t                result.set(currentHash, prevBranches);\n\t                if (current.parents.length > 0) {\n\t                    queue.push(current.parents[0]);\n\t                }\n\t            }\n\t        });\n\t        return result;\n\t    }\n\t}\n\texports.GitgraphUserApi = GitgraphUserApi;\n\n\t});\n\n\tunwrapExports(gitgraphUserApi);\n\tvar gitgraphUserApi_1 = gitgraphUserApi.GitgraphUserApi;\n\n\tvar gitgraph = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\n\n\n\n\tclass GitgraphCore {\n\t    constructor(options = {}) {\n\t        this.refs = new refs.Refs();\n\t        this.tags = new refs.Refs();\n\t        this.tagStyles = {};\n\t        this.tagRenders = {};\n\t        this.commits = [];\n\t        this.branches = new Map();\n\t        this.listeners = [];\n\t        this.nextTimeoutId = null;\n\t        this.template = template.getTemplate(options.template);\n\t        // Set a default `master` branch\n\t        this.currentBranch = this.createBranch(\"master\");\n\t        // Set all options with default values\n\t        this.orientation = options.orientation;\n\t        this.reverseArrow = utils.booleanOptionOr(options.reverseArrow, false);\n\t        this.initCommitOffsetX = utils.numberOptionOr(options.initCommitOffsetX, 0);\n\t        this.initCommitOffsetY = utils.numberOptionOr(options.initCommitOffsetY, 0);\n\t        this.mode = options.mode;\n\t        this.author = options.author || \"Sergio Flores <saxo-guy@epic.com>\";\n\t        this.commitMessage =\n\t            options.commitMessage || \"He doesn't like George Michael! Boooo!\";\n\t        this.generateCommitHash =\n\t            typeof options.generateCommitHash === \"function\"\n\t                ? options.generateCommitHash\n\t                : () => undefined;\n\t        this.branchesOrderFunction =\n\t            typeof options.compareBranchesOrder === \"function\"\n\t                ? options.compareBranchesOrder\n\t                : undefined;\n\t    }\n\t    get isHorizontal() {\n\t        return (this.orientation === orientation.Orientation.Horizontal ||\n\t            this.orientation === orientation.Orientation.HorizontalReverse);\n\t    }\n\t    get isVertical() {\n\t        return !this.isHorizontal;\n\t    }\n\t    get isReverse() {\n\t        return (this.orientation === orientation.Orientation.HorizontalReverse ||\n\t            this.orientation === orientation.Orientation.VerticalReverse);\n\t    }\n\t    /**\n\t     * Return the API to manipulate Gitgraph as a user.\n\t     * Rendering library should give that API to their consumer.\n\t     */\n\t    getUserApi() {\n\t        return new gitgraphUserApi.GitgraphUserApi(this, () => this.next());\n\t    }\n\t    /**\n\t     * Add a change listener.\n\t     * It will be called any time the graph have changed (commit, merge…).\n\t     *\n\t     * @param listener A callback to be invoked on every change.\n\t     * @returns A function to remove this change listener.\n\t     */\n\t    subscribe(listener) {\n\t        this.listeners.push(listener);\n\t        let isSubscribed = true;\n\t        return () => {\n\t            if (!isSubscribed)\n\t                return;\n\t            isSubscribed = false;\n\t            const index = this.listeners.indexOf(listener);\n\t            this.listeners.splice(index, 1);\n\t        };\n\t    }\n\t    /**\n\t     * Return all data required for rendering.\n\t     * Rendering libraries will use this to implement their rendering strategy.\n\t     */\n\t    getRenderedData() {\n\t        const commits = this.computeRenderedCommits();\n\t        const branchesPaths = this.computeRenderedBranchesPaths(commits);\n\t        const commitMessagesX = this.computeCommitMessagesX(branchesPaths);\n\t        this.computeBranchesColor(commits, branchesPaths);\n\t        return { commits, branchesPaths, commitMessagesX };\n\t    }\n\t    createBranch(args) {\n\t        const defaultParentBranchName = \"HEAD\";\n\t        let options = {\n\t            gitgraph: this,\n\t            name: \"\",\n\t            parentCommitHash: this.refs.getCommit(defaultParentBranchName),\n\t            style: this.template.branch,\n\t            onGraphUpdate: () => this.next(),\n\t        };\n\t        if (typeof args === \"string\") {\n\t            options.name = args;\n\t            options.parentCommitHash = this.refs.getCommit(defaultParentBranchName);\n\t        }\n\t        else {\n\t            const parentBranchName = args.from\n\t                ? args.from.name\n\t                : defaultParentBranchName;\n\t            const parentCommitHash = this.refs.getCommit(parentBranchName) ||\n\t                (this.refs.hasCommit(args.from) ? args.from : undefined);\n\t            args.style = args.style || {};\n\t            options = Object.assign({}, options, args, { parentCommitHash, style: Object.assign({}, options.style, args.style, { label: Object.assign({}, options.style.label, args.style.label) }) });\n\t        }\n\t        const branch$1 = new branch.Branch(options);\n\t        this.branches.set(branch$1.name, branch$1);\n\t        return branch$1;\n\t    }\n\t    /**\n\t     * Return commits with data for rendering.\n\t     */\n\t    computeRenderedCommits() {\n\t        const branches = this.getBranches();\n\t        const commitsWithBranches = this.commits.map((commit) => this.withBranches(branches, commit));\n\t        const rows = graphRows.createGraphRows(this.mode, this.commits);\n\t        const branchesOrder$1 = new branchesOrder.BranchesOrder(commitsWithBranches, this.template.colors, this.branchesOrderFunction);\n\t        return (commitsWithBranches\n\t            .map((commit) => commit.setRefs(this.refs))\n\t            .map((commit) => this.withPosition(rows, branchesOrder$1, commit))\n\t            // Fallback commit computed color on branch color.\n\t            .map((commit) => commit.withDefaultColor(this.getBranchDefaultColor(branchesOrder$1, commit.branchToDisplay)))\n\t            // Tags need commit style to be computed (with default color).\n\t            .map((commit) => commit.setTags(this.tags, (name) => Object.assign({}, this.tagStyles[name], this.template.tag), (name) => this.tagRenders[name])));\n\t    }\n\t    /**\n\t     * Return branches paths with all data required for rendering.\n\t     *\n\t     * @param commits List of commits with rendering data computed\n\t     */\n\t    computeRenderedBranchesPaths(commits) {\n\t        return new branchesPaths.BranchesPathsCalculator(commits, this.branches, this.template.commit.spacing, this.isVertical, this.isReverse, () => branch.createDeletedBranch(this, this.template.branch, () => this.next())).execute();\n\t    }\n\t    /**\n\t     * Set branches colors based on branches paths.\n\t     *\n\t     * @param commits List of graph commits\n\t     * @param branchesPaths Branches paths to be rendered\n\t     */\n\t    computeBranchesColor(commits, branchesPaths) {\n\t        const branchesOrder$1 = new branchesOrder.BranchesOrder(commits, this.template.colors, this.branchesOrderFunction);\n\t        Array.from(branchesPaths).forEach(([branch]) => {\n\t            branch.computedColor =\n\t                branch.style.color ||\n\t                    this.getBranchDefaultColor(branchesOrder$1, branch.name);\n\t        });\n\t    }\n\t    /**\n\t     * Return commit messages X position for rendering.\n\t     *\n\t     * @param branchesPaths Branches paths to be rendered\n\t     */\n\t    computeCommitMessagesX(branchesPaths) {\n\t        const numberOfColumns = Array.from(branchesPaths).length;\n\t        return numberOfColumns * this.template.branch.spacing;\n\t    }\n\t    /**\n\t     * Add `branches` property to commit.\n\t     *\n\t     * @param branches All branches mapped by commit hash\n\t     * @param commit Commit\n\t     */\n\t    withBranches(branches, commit) {\n\t        let commitBranches = Array.from((branches.get(commit.hash) || new Set()).values());\n\t        if (commitBranches.length === 0) {\n\t            // No branch => branch has been deleted.\n\t            commitBranches = [branch.DELETED_BRANCH_NAME];\n\t        }\n\t        return commit.setBranches(commitBranches);\n\t    }\n\t    /**\n\t     * Get all branches from current commits.\n\t     */\n\t    getBranches() {\n\t        const result = new Map();\n\t        const queue = [];\n\t        const branches = this.refs.getAllNames().filter((name) => name !== \"HEAD\");\n\t        branches.forEach((branch) => {\n\t            const commitHash = this.refs.getCommit(branch);\n\t            if (commitHash) {\n\t                queue.push(commitHash);\n\t            }\n\t            while (queue.length > 0) {\n\t                const currentHash = queue.pop();\n\t                const current = this.commits.find(({ hash }) => hash === currentHash);\n\t                const prevBranches = result.get(currentHash) || new Set();\n\t                prevBranches.add(branch);\n\t                result.set(currentHash, prevBranches);\n\t                if (current.parents.length > 0) {\n\t                    queue.push(current.parents[0]);\n\t                }\n\t            }\n\t        });\n\t        return result;\n\t    }\n\t    /**\n\t     * Add position to given commit.\n\t     *\n\t     * @param rows Graph rows\n\t     * @param branchesOrder Computed order of branches\n\t     * @param commit Commit to position\n\t     */\n\t    withPosition(rows, branchesOrder, commit) {\n\t        const row = rows.getRowOf(commit.hash);\n\t        const maxRow = rows.getMaxRow();\n\t        const order = branchesOrder.get(commit.branchToDisplay);\n\t        switch (this.orientation) {\n\t            default:\n\t                return commit.setPosition({\n\t                    x: this.initCommitOffsetX + this.template.branch.spacing * order,\n\t                    y: this.initCommitOffsetY +\n\t                        this.template.commit.spacing * (maxRow - row),\n\t                });\n\t            case orientation.Orientation.VerticalReverse:\n\t                return commit.setPosition({\n\t                    x: this.initCommitOffsetX + this.template.branch.spacing * order,\n\t                    y: this.initCommitOffsetY + this.template.commit.spacing * row,\n\t                });\n\t            case orientation.Orientation.Horizontal:\n\t                return commit.setPosition({\n\t                    x: this.initCommitOffsetX + this.template.commit.spacing * row,\n\t                    y: this.initCommitOffsetY + this.template.branch.spacing * order,\n\t                });\n\t            case orientation.Orientation.HorizontalReverse:\n\t                return commit.setPosition({\n\t                    x: this.initCommitOffsetX +\n\t                        this.template.commit.spacing * (maxRow - row),\n\t                    y: this.initCommitOffsetY + this.template.branch.spacing * order,\n\t                });\n\t        }\n\t    }\n\t    /**\n\t     * Return the default color for given branch.\n\t     *\n\t     * @param branchesOrder Computed order of branches\n\t     * @param branchName Name of the branch\n\t     */\n\t    getBranchDefaultColor(branchesOrder, branchName) {\n\t        return branchesOrder.getColorOf(branchName);\n\t    }\n\t    /**\n\t     * Tell each listener something new happened.\n\t     * E.g. a rendering library will know it needs to re-render the graph.\n\t     */\n\t    next() {\n\t        if (this.nextTimeoutId) {\n\t            window.clearTimeout(this.nextTimeoutId);\n\t        }\n\t        // Use setTimeout() with `0` to debounce call to next tick.\n\t        this.nextTimeoutId = window.setTimeout(() => {\n\t            this.listeners.forEach((listener) => listener(this.getRenderedData()));\n\t        }, 0);\n\t    }\n\t}\n\texports.GitgraphCore = GitgraphCore;\n\n\t});\n\n\tunwrapExports(gitgraph);\n\tvar gitgraph_1 = gitgraph.GitgraphCore;\n\n\tvar lib = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\texports.GitgraphCore = gitgraph.GitgraphCore;\n\n\texports.Mode = mode.Mode;\n\n\texports.GitgraphUserApi = gitgraphUserApi.GitgraphUserApi;\n\n\texports.BranchUserApi = branchUserApi.BranchUserApi;\n\n\texports.Branch = branch.Branch;\n\n\texports.Commit = commit.Commit;\n\n\texports.Tag = tag.Tag;\n\n\texports.Refs = refs.Refs;\n\n\texports.MergeStyle = template.MergeStyle;\n\texports.TemplateName = template.TemplateName;\n\texports.templateExtend = template.templateExtend;\n\n\texports.Orientation = orientation.Orientation;\n\n\texports.toSvgPath = branchesPaths.toSvgPath;\n\n\texports.arrowSvgPath = utils.arrowSvgPath;\n\n\t});\n\n\tunwrapExports(lib);\n\tvar lib_1 = lib.GitgraphCore;\n\tvar lib_2 = lib.Mode;\n\tvar lib_3 = lib.GitgraphUserApi;\n\tvar lib_4 = lib.BranchUserApi;\n\tvar lib_5 = lib.Branch;\n\tvar lib_6 = lib.Commit;\n\tvar lib_7 = lib.Tag;\n\tvar lib_8 = lib.Refs;\n\tvar lib_9 = lib.MergeStyle;\n\tvar lib_10 = lib.TemplateName;\n\tvar lib_11 = lib.templateExtend;\n\tvar lib_12 = lib.Orientation;\n\tvar lib_13 = lib.toSvgPath;\n\tvar lib_14 = lib.arrowSvgPath;\n\n\tvar SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\n\tfunction createSvg(options) {\n\t    var svg = document.createElementNS(SVG_NAMESPACE, \"svg\");\n\t    if (!options)\n\t        return svg;\n\t    if (options.children) {\n\t        options.children.forEach(function (child) { return svg.appendChild(child); });\n\t    }\n\t    if (options.viewBox) {\n\t        svg.setAttribute(\"viewBox\", options.viewBox);\n\t    }\n\t    if (options.height) {\n\t        svg.setAttribute(\"height\", options.height.toString());\n\t    }\n\t    if (options.width) {\n\t        svg.setAttribute(\"width\", options.width.toString());\n\t    }\n\t    return svg;\n\t}\n\tfunction createG(options) {\n\t    var g = document.createElementNS(SVG_NAMESPACE, \"g\");\n\t    options.children.forEach(function (child) { return child && g.appendChild(child); });\n\t    if (options.translate) {\n\t        g.setAttribute(\"transform\", \"translate(\" + options.translate.x + \", \" + options.translate.y + \")\");\n\t    }\n\t    if (options.fill) {\n\t        g.setAttribute(\"fill\", options.fill);\n\t    }\n\t    if (options.stroke) {\n\t        g.setAttribute(\"stroke\", options.stroke);\n\t    }\n\t    if (options.strokeWidth) {\n\t        g.setAttribute(\"stroke-width\", options.strokeWidth.toString());\n\t    }\n\t    if (options.onClick) {\n\t        g.addEventListener(\"click\", options.onClick);\n\t    }\n\t    if (options.onMouseOver) {\n\t        g.addEventListener(\"mouseover\", options.onMouseOver);\n\t    }\n\t    if (options.onMouseOut) {\n\t        g.addEventListener(\"mouseout\", options.onMouseOut);\n\t    }\n\t    return g;\n\t}\n\tfunction createText(options) {\n\t    var text = document.createElementNS(SVG_NAMESPACE, \"text\");\n\t    text.setAttribute(\"alignment-baseline\", \"central\");\n\t    text.setAttribute(\"dominant-baseline\", \"central\");\n\t    text.textContent = options.content;\n\t    if (options.fill) {\n\t        text.setAttribute(\"fill\", options.fill);\n\t    }\n\t    if (options.font) {\n\t        text.setAttribute(\"style\", \"font: \" + options.font);\n\t    }\n\t    if (options.anchor) {\n\t        text.setAttribute(\"text-anchor\", options.anchor);\n\t    }\n\t    if (options.translate) {\n\t        text.setAttribute(\"x\", options.translate.x.toString());\n\t        text.setAttribute(\"y\", options.translate.y.toString());\n\t    }\n\t    if (options.onClick) {\n\t        text.addEventListener(\"click\", options.onClick);\n\t    }\n\t    return text;\n\t}\n\tfunction createCircle(options) {\n\t    var circle = document.createElementNS(SVG_NAMESPACE, \"circle\");\n\t    circle.setAttribute(\"cx\", options.radius.toString());\n\t    circle.setAttribute(\"cy\", options.radius.toString());\n\t    circle.setAttribute(\"r\", options.radius.toString());\n\t    if (options.id) {\n\t        circle.setAttribute(\"id\", options.id);\n\t    }\n\t    if (options.fill) {\n\t        circle.setAttribute(\"fill\", options.fill);\n\t    }\n\t    return circle;\n\t}\n\tfunction createRect(options) {\n\t    var rect = document.createElementNS(SVG_NAMESPACE, \"rect\");\n\t    rect.setAttribute(\"width\", options.width.toString());\n\t    rect.setAttribute(\"height\", options.height.toString());\n\t    if (options.borderRadius) {\n\t        rect.setAttribute(\"rx\", options.borderRadius.toString());\n\t    }\n\t    if (options.fill) {\n\t        rect.setAttribute(\"fill\", options.fill || \"transparent\");\n\t    }\n\t    if (options.stroke) {\n\t        rect.setAttribute(\"stroke\", options.stroke);\n\t    }\n\t    return rect;\n\t}\n\tfunction createPath(options) {\n\t    var path = document.createElementNS(SVG_NAMESPACE, \"path\");\n\t    path.setAttribute(\"d\", options.d);\n\t    if (options.fill) {\n\t        path.setAttribute(\"fill\", options.fill);\n\t    }\n\t    if (options.stroke) {\n\t        path.setAttribute(\"stroke\", options.stroke);\n\t    }\n\t    if (options.strokeWidth) {\n\t        path.setAttribute(\"stroke-width\", options.strokeWidth.toString());\n\t    }\n\t    if (options.translate) {\n\t        path.setAttribute(\"transform\", \"translate(\" + options.translate.x + \", \" + options.translate.y + \")\");\n\t    }\n\t    return path;\n\t}\n\tfunction createUse(href) {\n\t    var use = document.createElementNS(SVG_NAMESPACE, \"use\");\n\t    use.setAttribute(\"href\", \"#\" + href);\n\t    // xlink:href is deprecated in SVG2, but we keep it for retro-compatibility\n\t    // => https://developer.mozilla.org/en-US/docs/Web/SVG/Element/use#Browser_compatibility\n\t    use.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", \"#\" + href);\n\t    return use;\n\t}\n\tfunction createClipPath() {\n\t    return document.createElementNS(SVG_NAMESPACE, \"clipPath\");\n\t}\n\tfunction createDefs(children) {\n\t    var defs = document.createElementNS(SVG_NAMESPACE, \"defs\");\n\t    children.forEach(function (child) { return defs.appendChild(child); });\n\t    return defs;\n\t}\n\tfunction createForeignObject(options) {\n\t    var result = document.createElementNS(SVG_NAMESPACE, \"foreignObject\");\n\t    result.setAttribute(\"width\", options.width.toString());\n\t    if (options.translate) {\n\t        result.setAttribute(\"x\", options.translate.x.toString());\n\t        result.setAttribute(\"y\", options.translate.y.toString());\n\t    }\n\t    var p = document.createElement(\"p\");\n\t    p.textContent = options.content;\n\t    result.appendChild(p);\n\t    return result;\n\t}\n\n\tvar PADDING_X = 10;\n\tvar PADDING_Y = 5;\n\tfunction createBranchLabel(branch, commit) {\n\t    var rect = createRect({\n\t        width: 0,\n\t        height: 0,\n\t        borderRadius: branch.style.label.borderRadius,\n\t        stroke: branch.style.label.strokeColor || commit.style.color,\n\t        fill: branch.style.label.bgColor,\n\t    });\n\t    var text = createText({\n\t        content: branch.name,\n\t        translate: {\n\t            x: PADDING_X,\n\t            y: 0,\n\t        },\n\t        font: branch.style.label.font,\n\t        fill: branch.style.label.color || commit.style.color,\n\t    });\n\t    var branchLabel = createG({ children: [rect] });\n\t    var observer = new MutationObserver(function () {\n\t        var _a = text.getBBox(), height = _a.height, width = _a.width;\n\t        var boxWidth = width + 2 * PADDING_X;\n\t        var boxHeight = height + 2 * PADDING_Y;\n\t        // Ideally, it would be great to refactor these behavior into SVG elements.\n\t        rect.setAttribute(\"width\", boxWidth.toString());\n\t        rect.setAttribute(\"height\", boxHeight.toString());\n\t        text.setAttribute(\"y\", (boxHeight / 2).toString());\n\t    });\n\t    observer.observe(branchLabel, {\n\t        attributes: false,\n\t        subtree: false,\n\t        childList: true,\n\t    });\n\t    // Add text after observer is set up => react based on text size.\n\t    // We might refactor it by including `onChildrenUpdate()` to `createG()`.\n\t    branchLabel.appendChild(text);\n\t    return branchLabel;\n\t}\n\n\tvar PADDING_X$1 = 10;\n\tvar PADDING_Y$1 = 5;\n\tfunction createTag(tag) {\n\t    var path = createPath({\n\t        d: \"\",\n\t        fill: tag.style.bgColor,\n\t        stroke: tag.style.strokeColor,\n\t    });\n\t    var text = createText({\n\t        content: tag.name,\n\t        fill: tag.style.color,\n\t        font: tag.style.font,\n\t        translate: { x: 0, y: 0 },\n\t    });\n\t    var result = createG({ children: [path] });\n\t    var offset = tag.style.pointerWidth;\n\t    var observer = new MutationObserver(function () {\n\t        var _a = text.getBBox(), height = _a.height, width = _a.width;\n\t        if (height === 0 || width === 0)\n\t            return;\n\t        var radius = tag.style.borderRadius;\n\t        var boxWidth = offset + width + 2 * PADDING_X$1;\n\t        var boxHeight = height + 2 * PADDING_Y$1;\n\t        var pathD = [\n\t            \"M 0,0\",\n\t            \"L \" + offset + \",\" + boxHeight / 2,\n\t            \"V \" + boxHeight / 2,\n\t            \"Q \" + offset + \",\" + boxHeight / 2 + \" \" + (offset + radius) + \",\" + boxHeight / 2,\n\t            \"H \" + (boxWidth - radius),\n\t            \"Q \" + boxWidth + \",\" + boxHeight / 2 + \" \" + boxWidth + \",\" + (boxHeight / 2 - radius),\n\t            \"V -\" + (boxHeight / 2 - radius),\n\t            \"Q \" + boxWidth + \",-\" + boxHeight / 2 + \" \" + (boxWidth - radius) + \",-\" + boxHeight / 2,\n\t            \"H \" + (offset + radius),\n\t            \"Q \" + offset + \",-\" + boxHeight / 2 + \" \" + offset + \",-\" + boxHeight / 2,\n\t            \"V -\" + boxHeight / 2,\n\t            \"z\",\n\t        ].join(\" \");\n\t        // Ideally, it would be great to refactor these behavior into SVG elements.\n\t        path.setAttribute(\"d\", pathD.toString());\n\t        text.setAttribute(\"x\", (offset + PADDING_X$1).toString());\n\t    });\n\t    observer.observe(result, {\n\t        attributes: false,\n\t        subtree: false,\n\t        childList: true,\n\t    });\n\t    // Add text after observer is set up => react based on text size.\n\t    // We might refactor it by including `onChildrenUpdate()` to `createG()`.\n\t    result.appendChild(text);\n\t    return result;\n\t}\n\n\tvar PADDING = 10;\n\tvar OFFSET = 10;\n\tfunction createTooltip(commit) {\n\t    var path = createPath({ d: \"\", fill: \"#EEE\" });\n\t    var text = createText({\n\t        translate: { x: OFFSET + PADDING, y: 0 },\n\t        content: commit.hashAbbrev + \" - \" + commit.subject,\n\t        fill: \"#333\",\n\t    });\n\t    var commitSize = commit.style.dot.size * 2;\n\t    var tooltip = createG({\n\t        translate: { x: commitSize, y: commitSize / 2 },\n\t        children: [path],\n\t    });\n\t    var observer = new MutationObserver(function () {\n\t        var width = text.getBBox().width;\n\t        var radius = 5;\n\t        var boxHeight = 50;\n\t        var boxWidth = OFFSET + width + 2 * PADDING;\n\t        var pathD = [\n\t            \"M 0,0\",\n\t            \"L \" + OFFSET + \",\" + OFFSET,\n\t            \"V \" + (boxHeight / 2 - radius),\n\t            \"Q \" + OFFSET + \",\" + boxHeight / 2 + \" \" + (OFFSET + radius) + \",\" + boxHeight / 2,\n\t            \"H \" + (boxWidth - radius),\n\t            \"Q \" + boxWidth + \",\" + boxHeight / 2 + \" \" + boxWidth + \",\" + (boxHeight / 2 - radius),\n\t            \"V -\" + (boxHeight / 2 - radius),\n\t            \"Q \" + boxWidth + \",-\" + boxHeight / 2 + \" \" + (boxWidth - radius) + \",-\" + boxHeight / 2,\n\t            \"H \" + (OFFSET + radius),\n\t            \"Q \" + OFFSET + \",-\" + boxHeight / 2 + \" \" + OFFSET + \",-\" + (boxHeight / 2 - radius),\n\t            \"V -\" + OFFSET,\n\t            \"z\",\n\t        ].join(\" \");\n\t        // Ideally, it would be great to refactor these behavior into SVG elements.\n\t        // rect.setAttribute(\"width\", boxWidth.toString());\n\t        path.setAttribute(\"d\", pathD.toString());\n\t    });\n\t    observer.observe(tooltip, {\n\t        attributes: false,\n\t        subtree: false,\n\t        childList: true,\n\t    });\n\t    tooltip.appendChild(text);\n\t    return tooltip;\n\t}\n\n\tfunction createGitgraph(graphContainer, options) {\n\t    var commitsElements = {};\n\t    // Store a map to replace commits y with the correct value,\n\t    // including the message offset. Allows custom, flexible message height.\n\t    // E.g. {20: 30} means for commit: y=20 -> y=30\n\t    // Offset should be computed when graph is rendered (componentDidUpdate).\n\t    var commitYWithOffsets = {};\n\t    var shouldRecomputeOffsets = false;\n\t    var lastData;\n\t    var $commits;\n\t    var commitMessagesX = 0;\n\t    var $tooltip = null;\n\t    // Create an `svg` context in which we'll render the graph.\n\t    var svg = createSvg();\n\t    adaptSvgOnUpdate();\n\t    graphContainer.appendChild(svg);\n\t    // React on gitgraph updates to re-render the graph.\n\t    var gitgraph = new lib_1(options);\n\t    gitgraph.subscribe(function (data) {\n\t        shouldRecomputeOffsets = true;\n\t        render(data);\n\t    });\n\t    // Return usable API for end-user.\n\t    return gitgraph.getUserApi();\n\t    function render(data) {\n\t        // Reset before new rendering to flush previous state.\n\t        commitsElements = {};\n\t        var commits = data.commits, branchesPaths = data.branchesPaths;\n\t        commitMessagesX = data.commitMessagesX;\n\t        // Store data so we can re-render after offsets are computed.\n\t        lastData = data;\n\t        // Store $commits so we can compute offsets from actual height.\n\t        $commits = renderCommits(commits);\n\t        // Reset SVG with new content.\n\t        svg.innerHTML = \"\";\n\t        svg.appendChild(createG({\n\t            // Translate graph left => left-most branch label is not cropped (horizontal)\n\t            // Translate graph down => top-most commit tooltip is not cropped\n\t            translate: { x: PADDING_X, y: PADDING },\n\t            children: [renderBranchesPaths(branchesPaths), $commits],\n\t        }));\n\t    }\n\t    function adaptSvgOnUpdate() {\n\t        var observer = new MutationObserver(function () {\n\t            if (shouldRecomputeOffsets) {\n\t                shouldRecomputeOffsets = false;\n\t                computeOffsets();\n\t                render(lastData);\n\t            }\n\t            else {\n\t                positionCommitsElements();\n\t                adaptGraphDimensions();\n\t            }\n\t        });\n\t        observer.observe(svg, {\n\t            attributes: false,\n\t            // Listen to subtree changes to react when we append the tooltip.\n\t            subtree: true,\n\t            childList: true,\n\t        });\n\t        function computeOffsets() {\n\t            var commits = Array.from($commits.children);\n\t            var totalOffsetY = 0;\n\t            // In VerticalReverse orientation, commits are in the same order in the DOM.\n\t            var orientedCommits = gitgraph.orientation === lib_12.VerticalReverse\n\t                ? commits\n\t                : commits.reverse();\n\t            commitYWithOffsets = orientedCommits.reduce(function (newOffsets, commit) {\n\t                var commitY = parseInt(commit\n\t                    .getAttribute(\"transform\")\n\t                    .split(\",\")[1]\n\t                    .slice(0, -1), 10);\n\t                var firstForeignObject = commit.getElementsByTagName(\"foreignObject\")[0];\n\t                var customHtmlMessage = firstForeignObject && firstForeignObject.firstElementChild;\n\t                newOffsets[commitY] = commitY + totalOffsetY;\n\t                // Increment total offset after setting the offset\n\t                // => offset next commits accordingly.\n\t                totalOffsetY += getMessageHeight(customHtmlMessage);\n\t                return newOffsets;\n\t            }, {});\n\t        }\n\t        function positionCommitsElements() {\n\t            if (gitgraph.isHorizontal) {\n\t                // Elements don't appear on horizontal mode, yet.\n\t                return;\n\t            }\n\t            var padding = 10;\n\t            // Ensure commits elements (branch labels, message…) are well positionned.\n\t            // It can't be done at render time since elements size is dynamic.\n\t            Object.keys(commitsElements).forEach(function (commitHash) {\n\t                var _a = commitsElements[commitHash], branchLabel = _a.branchLabel, tags = _a.tags, message = _a.message;\n\t                // We'll store X position progressively and translate elements.\n\t                var x = commitMessagesX;\n\t                if (branchLabel) {\n\t                    moveElement(branchLabel, x);\n\t                    // BBox width misses box padding\n\t                    // => they are set later, on branch label update.\n\t                    // We would need to make branch label update happen before to solve it.\n\t                    var branchLabelWidth = branchLabel.getBBox().width + 2 * PADDING_X;\n\t                    x += branchLabelWidth + padding;\n\t                }\n\t                tags.forEach(function (tag) {\n\t                    moveElement(tag, x);\n\t                    // BBox width misses box padding and offset\n\t                    // => they are set later, on tag update.\n\t                    // We would need to make tag update happen before to solve it.\n\t                    var offset = parseFloat(tag.getAttribute(\"data-offset\") || \"0\");\n\t                    var tagWidth = tag.getBBox().width + 2 * PADDING_X$1 + offset;\n\t                    x += tagWidth + padding;\n\t                });\n\t                if (message) {\n\t                    moveElement(message, x);\n\t                }\n\t            });\n\t        }\n\t        function adaptGraphDimensions() {\n\t            var _a = svg.getBBox(), height = _a.height, width = _a.width;\n\t            // FIXME: In horizontal mode, we mimic @gitgraph/react behavior\n\t            // => it gets re-rendered after offsets are computed\n\t            // => it applies paddings twice!\n\t            //\n\t            // It works… by chance. Technically, we should compute what would\n\t            // *actually* go beyond the computed limits of the graph.\n\t            var horizontalCustomOffset = 50;\n\t            var widthOffset = gitgraph.isHorizontal\n\t                ? horizontalCustomOffset\n\t                : // Add `TOOLTIP_PADDING` so we don't crop the tooltip text.\n\t                    // Add `BRANCH_LABEL_PADDING_X` so we don't cut branch label.\n\t                    PADDING_X + PADDING;\n\t            var heightOffset = gitgraph.isHorizontal\n\t                ? horizontalCustomOffset\n\t                : // Add `TOOLTIP_PADDING` so we don't crop tooltip text\n\t                    // Add `BRANCH_LABEL_PADDING_Y` so we don't crop branch label.\n\t                    PADDING_Y + PADDING;\n\t            svg.setAttribute(\"width\", (width + widthOffset).toString());\n\t            svg.setAttribute(\"height\", (height + heightOffset).toString());\n\t        }\n\t    }\n\t    function moveElement(target, x) {\n\t        var transform = target.getAttribute(\"transform\") || \"translate(0, 0)\";\n\t        target.setAttribute(\"transform\", transform.replace(/translate\\(([\\d\\.]+),/, \"translate(\" + x + \",\"));\n\t    }\n\t    function renderBranchesPaths(branchesPaths) {\n\t        var offset = gitgraph.template.commit.dot.size;\n\t        var isBezier = gitgraph.template.branch.mergeStyle === lib_9.Bezier;\n\t        var paths = Array.from(branchesPaths).map(function (_a) {\n\t            var branch = _a[0], coordinates = _a[1];\n\t            return createPath({\n\t                d: lib_13(coordinates.map(function (coordinate) { return coordinate.map(getWithCommitOffset); }), isBezier, gitgraph.isVertical),\n\t                fill: \"transparent\",\n\t                stroke: branch.computedColor || \"\",\n\t                strokeWidth: branch.style.lineWidth,\n\t                translate: {\n\t                    x: offset,\n\t                    y: offset,\n\t                },\n\t            });\n\t        });\n\t        return createG({ children: paths });\n\t    }\n\t    function renderCommits(commits) {\n\t        return createG({ children: commits.map(renderCommit) });\n\t        function renderCommit(commit) {\n\t            var _a = getWithCommitOffset(commit), x = _a.x, y = _a.y;\n\t            return createG({\n\t                translate: { x: x, y: y },\n\t                children: [\n\t                    renderDot(commit)\n\t                ].concat(renderArrows(commit), [\n\t                    createG({\n\t                        translate: { x: -x, y: 0 },\n\t                        children: [\n\t                            renderMessage(commit)\n\t                        ].concat(renderBranchLabels(commit), renderTags(commit)),\n\t                    }),\n\t                ]),\n\t            });\n\t        }\n\t        function renderArrows(commit) {\n\t            if (!gitgraph.template.arrow.size) {\n\t                return [null];\n\t            }\n\t            var commitRadius = commit.style.dot.size;\n\t            return commit.parents.map(function (parentHash) {\n\t                var parent = commits.find(function (_a) {\n\t                    var hash = _a.hash;\n\t                    return hash === parentHash;\n\t                });\n\t                if (!parent)\n\t                    return null;\n\t                // Starting point, relative to commit\n\t                var origin = gitgraph.reverseArrow\n\t                    ? {\n\t                        x: commitRadius + (parent.x - commit.x),\n\t                        y: commitRadius + (parent.y - commit.y),\n\t                    }\n\t                    : { x: commitRadius, y: commitRadius };\n\t                var path = createPath({\n\t                    d: lib_14(gitgraph, parent, commit),\n\t                    fill: gitgraph.template.arrow.color || \"\",\n\t                });\n\t                return createG({ translate: origin, children: [path] });\n\t            });\n\t        }\n\t    }\n\t    function renderMessage(commit) {\n\t        if (!commit.style.message.display) {\n\t            return null;\n\t        }\n\t        var message;\n\t        if (commit.renderMessage) {\n\t            message = createG({ children: [] });\n\t            // Add message after observer is set up => react based on body height.\n\t            // We might refactor it by including `onChildrenUpdate()` to `createG()`.\n\t            adaptMessageBodyHeight(message);\n\t            message.appendChild(commit.renderMessage(commit));\n\t            setMessageRef(commit, message);\n\t            return message;\n\t        }\n\t        var text = createText({\n\t            content: commit.message,\n\t            fill: commit.style.message.color || \"\",\n\t            font: commit.style.message.font,\n\t            onClick: commit.onMessageClick,\n\t        });\n\t        message = createG({\n\t            translate: { x: 0, y: commit.style.dot.size },\n\t            children: [text],\n\t        });\n\t        if (commit.body) {\n\t            var body = createForeignObject({\n\t                width: 600,\n\t                translate: { x: 10, y: 0 },\n\t                content: commit.body,\n\t            });\n\t            // Add message after observer is set up => react based on body height.\n\t            // We might refactor it by including `onChildrenUpdate()` to `createG()`.\n\t            adaptMessageBodyHeight(message);\n\t            message.appendChild(body);\n\t        }\n\t        setMessageRef(commit, message);\n\t        return message;\n\t    }\n\t    function adaptMessageBodyHeight(message) {\n\t        var observer = new MutationObserver(function (mutations) {\n\t            mutations.forEach(function (_a) {\n\t                var target = _a.target;\n\t                return setChildrenForeignObjectHeight(target);\n\t            });\n\t        });\n\t        observer.observe(message, {\n\t            attributes: false,\n\t            subtree: false,\n\t            childList: true,\n\t        });\n\t        function setChildrenForeignObjectHeight(node) {\n\t            if (node.nodeName === \"foreignObject\") {\n\t                // We have to access the first child's parentElement to retrieve\n\t                // the Element instead of the Node => we can compute dimensions.\n\t                var foreignObject = node.firstChild && node.firstChild.parentElement;\n\t                if (!foreignObject)\n\t                    return;\n\t                // Force the height of the foreignObject (browser issue)\n\t                foreignObject.setAttribute(\"height\", getMessageHeight(foreignObject.firstElementChild).toString());\n\t            }\n\t            node.childNodes.forEach(setChildrenForeignObjectHeight);\n\t        }\n\t    }\n\t    function renderBranchLabels(commit) {\n\t        // @gitgraph/core could compute branch labels into commits directly.\n\t        // That will make it easier to retrieve them, just like tags.\n\t        var branches = Array.from(gitgraph.branches.values());\n\t        return branches.map(function (branch) {\n\t            if (!branch.style.label.display)\n\t                return null;\n\t            var commitHash = gitgraph.refs.getCommit(branch.name);\n\t            if (commit.hash !== commitHash)\n\t                return null;\n\t            // For the moment, we don't handle multiple branch labels.\n\t            // To do so, we'd need to reposition each of them appropriately.\n\t            if (commit.branchToDisplay !== branch.name)\n\t                return null;\n\t            var branchLabel = branch.renderLabel\n\t                ? branch.renderLabel(branch)\n\t                : createBranchLabel(branch, commit);\n\t            var branchLabelContainer;\n\t            if (gitgraph.isVertical) {\n\t                branchLabelContainer = createG({\n\t                    children: [branchLabel],\n\t                });\n\t            }\n\t            else {\n\t                var commitDotSize = commit.style.dot.size * 2;\n\t                var horizontalMarginTop = 10;\n\t                branchLabelContainer = createG({\n\t                    translate: { x: commit.x, y: commitDotSize + horizontalMarginTop },\n\t                    children: [branchLabel],\n\t                });\n\t            }\n\t            setBranchLabelRef(commit, branchLabelContainer);\n\t            return branchLabelContainer;\n\t        });\n\t    }\n\t    function renderTags(commit) {\n\t        if (!commit.tags)\n\t            return [];\n\t        if (gitgraph.isHorizontal)\n\t            return [];\n\t        return commit.tags.map(function (tag) {\n\t            var tagElement = tag.render\n\t                ? tag.render(tag.name, tag.style)\n\t                : createTag(tag);\n\t            var tagContainer = createG({\n\t                translate: { x: 0, y: commit.style.dot.size },\n\t                children: [tagElement],\n\t            });\n\t            // `data-offset` is used to position tag element in `positionCommitsElements`.\n\t            // => because when it's executed, tag offsets are not resolved yet\n\t            tagContainer.setAttribute(\"data-offset\", tag.style.pointerWidth.toString());\n\t            setTagRef(commit, tagContainer);\n\t            return tagContainer;\n\t        });\n\t    }\n\t    function renderDot(commit) {\n\t        if (commit.renderDot) {\n\t            return commit.renderDot(commit);\n\t        }\n\t        /*\n\t        In order to handle strokes, we need to do some complex stuff here… 😅\n\t    \n\t        Problem: strokes are drawn inside & outside the circle.\n\t        But we want the stroke to be drawn inside only!\n\t    \n\t        The outside overlaps with other elements, as we expect the dot to have a fixed size. So we want to crop the outside part.\n\t    \n\t        Solution:\n\t        1. Create the circle in a <defs>\n\t        2. Define a clip path that references the circle\n\t        3. Use the clip path, adding the stroke.\n\t        4. Double stroke width as half of it will be clipped (the outside part).\n\t    \n\t        Ref.: https://stackoverflow.com/a/32162431/3911841\n\t    \n\t        P.S. there is a proposal for a stroke-alignment property,\n\t        but it's still a W3C Draft ¯\\_(ツ)_/¯\n\t        https://svgwg.org/specs/strokes/#SpecifyingStrokeAlignment\n\t      */\n\t        var circleId = commit.hash;\n\t        var circle = createCircle({\n\t            id: circleId,\n\t            radius: commit.style.dot.size,\n\t            fill: commit.style.dot.color || \"\",\n\t        });\n\t        var clipPathId = \"clip-\" + commit.hash;\n\t        var circleClipPath = createClipPath();\n\t        circleClipPath.setAttribute(\"id\", clipPathId);\n\t        circleClipPath.appendChild(createUse(circleId));\n\t        var useCirclePath = createUse(circleId);\n\t        useCirclePath.setAttribute(\"clip-path\", \"url(#\" + clipPathId + \")\");\n\t        useCirclePath.setAttribute(\"stroke\", commit.style.dot.strokeColor || \"\");\n\t        var strokeWidth = commit.style.dot.strokeWidth\n\t            ? commit.style.dot.strokeWidth * 2\n\t            : 0;\n\t        useCirclePath.setAttribute(\"stroke-width\", strokeWidth.toString());\n\t        var dotText = commit.dotText\n\t            ? createText({\n\t                content: commit.dotText,\n\t                font: commit.style.dot.font,\n\t                anchor: \"middle\",\n\t                translate: { x: commit.style.dot.size, y: commit.style.dot.size },\n\t            })\n\t            : null;\n\t        return createG({\n\t            onClick: commit.onClick,\n\t            onMouseOver: function () {\n\t                appendTooltipToGraph(commit);\n\t                commit.onMouseOver();\n\t            },\n\t            onMouseOut: function () {\n\t                if ($tooltip)\n\t                    $tooltip.remove();\n\t                commit.onMouseOut();\n\t            },\n\t            children: [createDefs([circle, circleClipPath]), useCirclePath, dotText],\n\t        });\n\t    }\n\t    function appendTooltipToGraph(commit) {\n\t        if (!svg.firstChild)\n\t            return;\n\t        if (gitgraph.isVertical && gitgraph.mode !== lib_2.Compact)\n\t            return;\n\t        if (gitgraph.isVertical && !commit.style.hasTooltipInCompactMode)\n\t            return;\n\t        var tooltip = commit.renderTooltip\n\t            ? commit.renderTooltip(commit)\n\t            : createTooltip(commit);\n\t        $tooltip = createG({\n\t            translate: getWithCommitOffset(commit),\n\t            children: [tooltip],\n\t        });\n\t        svg.firstChild.appendChild($tooltip);\n\t    }\n\t    function getWithCommitOffset(_a) {\n\t        var x = _a.x, y = _a.y;\n\t        return { x: x, y: commitYWithOffsets[y] || y };\n\t    }\n\t    function setBranchLabelRef(commit, branchLabels) {\n\t        if (!commitsElements[commit.hashAbbrev]) {\n\t            initCommitElements(commit);\n\t        }\n\t        commitsElements[commit.hashAbbrev].branchLabel = branchLabels;\n\t    }\n\t    function setMessageRef(commit, message) {\n\t        if (!commitsElements[commit.hashAbbrev]) {\n\t            initCommitElements(commit);\n\t        }\n\t        commitsElements[commit.hashAbbrev].message = message;\n\t    }\n\t    function setTagRef(commit, tag) {\n\t        if (!commitsElements[commit.hashAbbrev]) {\n\t            initCommitElements(commit);\n\t        }\n\t        commitsElements[commit.hashAbbrev].tags.push(tag);\n\t    }\n\t    function initCommitElements(commit) {\n\t        commitsElements[commit.hashAbbrev] = {\n\t            branchLabel: null,\n\t            tags: [],\n\t            message: null,\n\t        };\n\t    }\n\t}\n\tfunction getMessageHeight(message) {\n\t    var messageHeight = 0;\n\t    if (message) {\n\t        var height = message.getBoundingClientRect().height;\n\t        var marginTopInPx = window.getComputedStyle(message).marginTop || \"0px\";\n\t        var marginTop = parseInt(marginTopInPx.replace(\"px\", \"\"), 10);\n\t        messageHeight = height + marginTop;\n\t    }\n\t    return messageHeight;\n\t}\n\n\texports.MergeStyle = lib_9;\n\texports.Mode = lib_2;\n\texports.Orientation = lib_12;\n\texports.TemplateName = lib_10;\n\texports.createGitgraph = createGitgraph;\n\texports.templateExtend = lib_11;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\n","import { createGitgraph, TemplateName, templateExtend } from \"@gitgraph/js\";\n// Get the graph container HTML element.\nconst graphContainer = document.getElementById(\"regularFlowPmChange\");\n\n// Instantiate the graph.\nconst Revium = templateExtend(TemplateName.Metro, {\n  colors: [\"#0C0A3E\", \"#7B1E7A\", \"#B33F62\", \"#F9564F\", \"#F3C677\"],\n  branch: {\n    lineWidth: 4,\n    spacing: 50,\n    label: {\n      font: \"normal 10pt Arial\",\n      displayAuthor: false\n    }\n  },\n  commit: {\n    spacing: 60,\n    dot: {\n      size: 16,\n      strokeColor: \"#000000\",\n      strokeWidth: 2\n    },\n    message: {\n      displayAuthor: false,\n      font: \"normal 10pt Arial\"\n    }\n  }\n});\nconst gitgraph = createGitgraph(graphContainer, {\n  template: Revium\n});\n\n// Simulate git commands with Gitgraph API.\nconst master = gitgraph.branch(\"master\");\nmaster.commit(\"Initial commit\");\n\nconst staging = gitgraph.branch(\"staging\");\nstaging.commit(\"Initial commit\");\n\nconst dev = gitgraph.branch(\"dev\");\ndev.commit(\"Initial commit\");\n\nconst feature1 = gitgraph.branch(\"feature/30000-new-navigation-menu\");\nfeature1\n  .commit(\"created navigation\")\n  .commit(\"updated navigation js so that the hover works on mobile\")\n  .commit(\"added hover state color for desktop\");\n\ndev.merge(feature1);\n\nfeature1\n  .commit(\"PM noticed bug\")\n  .commit(\"fixed an issue on mobile where button could not be clicked\");\n\ndev.merge(feature1);\n\nstaging.merge(dev);\n\nmaster.merge(staging);\n","import { createGitgraph, TemplateName, templateExtend } from \"@gitgraph/js\";\n// Get the graph container HTML element.\nconst graphContainer = document.getElementById(\"hotfixChange\");\n\n// Instantiate the graph.\nconst Revium = templateExtend(TemplateName.Metro, {\n  colors: [\"#0C0A3E\", \"#7B1E7A\", \"#B33F62\", \"#F9564F\", \"#F3C677\"],\n  branch: {\n    lineWidth: 4,\n    spacing: 50,\n    label: {\n      font: \"normal 10pt Arial\",\n      displayAuthor: false\n    }\n  },\n  commit: {\n    spacing: 60,\n    dot: {\n      size: 16,\n      strokeColor: \"#000000\",\n      strokeWidth: 2\n    },\n    message: {\n      displayAuthor: false,\n      font: \"normal 10pt Arial\"\n    }\n  }\n});\nconst gitgraph = createGitgraph(graphContainer, {\n  template: Revium\n});\n\n// Simulate git commands with Gitgraph API.\nconst master = gitgraph.branch(\"master\");\nmaster.commit(\"Initial commit\");\n\nconst staging = gitgraph.branch(\"staging\");\nstaging.commit(\"Initial commit\");\n\nconst dev = gitgraph.branch(\"dev\");\ndev.commit(\"Initial commit\");\n\nconst feature1 = gitgraph.branch(\"feature/30000-new-navigation-menu\");\n\nfeature1\n  .commit(\"created navigation\")\n  .commit(\"updated navigation js so that it works in IE11\");\n\nconst hotfix = master.branch(\"hotfix/30001-iis-webconfig-update\");\n\nhotfix.commit(\"fixed 500 error on server\");\n\nmaster.merge(hotfix);\n\nfeature1.commit(\"added hover state color for desktop\");\n","import { createGitgraph, TemplateName, templateExtend } from \"@gitgraph/js\";\nimport \"./git2.js\";\nimport \"./git3.js\";\n\n// Get the graph container HTML element.\nconst graphContainer = document.getElementById(\"regularFlow\");\n\n// Instantiate the graph.\nconst Revium = templateExtend(TemplateName.Metro, {\n  colors: [\"#0C0A3E\", \"#7B1E7A\", \"#B33F62\", \"#F9564F\", \"#F3C677\"],\n  branch: {\n    lineWidth: 4,\n    spacing: 50,\n    label: {\n      font: \"normal 10pt Arial\",\n      displayAuthor: false\n    }\n  },\n  commit: {\n    spacing: 60,\n    dot: {\n      size: 16,\n      strokeColor: \"#000000\",\n      strokeWidth: 2\n    },\n    message: {\n      displayAuthor: false,\n      font: \"normal 10pt Arial\"\n    }\n  }\n});\nconst gitgraph = createGitgraph(graphContainer, {\n  template: Revium\n});\n// Simulate git commands with Gitgraph API.\nconst master = gitgraph.branch(\"master\");\nmaster.commit(\"Initial commit\");\n\nconst staging = gitgraph.branch(\"staging\");\nstaging.commit(\"Initial commit\");\n\nconst dev = gitgraph.branch(\"dev\");\ndev.commit(\"Initial commit\");\n\nconst feature1 = gitgraph.branch(\"feature/30000-new-navigation-menu\");\nfeature1\n  .commit(\"created navigation\")\n  .commit(\"updated navigation js so that the hover works on mobile\")\n  .commit(\"added hover state color for desktop\");\n\ndev.merge(feature1);\nstaging.merge(dev);\n\nmaster.merge(staging);\n","var OVERLAY_ID = '__parcel__error__overlay__';\n\nvar OldModule = module.bundle.Module;\n\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData,\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n\n  module.bundle.hotData = null;\n}\n\nmodule.bundle.Module = Module;\nvar checkedAssets, assetsToAccept;\n\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = process.env.HMR_HOSTNAME || location.hostname;\n  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';\n  var ws = new WebSocket(protocol + '://' + hostname + ':' + process.env.HMR_PORT + '/');\n  ws.onmessage = function(event) {\n    checkedAssets = {};\n    assetsToAccept = [];\n\n    var data = JSON.parse(event.data);\n\n    if (data.type === 'update') {\n      var handled = false;\n      data.assets.forEach(function(asset) {\n        if (!asset.isNew) {\n          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);\n          if (didAccept) {\n            handled = true;\n          }\n        }\n      });\n\n      // Enable HMR for CSS by default.\n      handled = handled || data.assets.every(function(asset) {\n        return asset.type === 'css' && asset.generated.js;\n      });\n\n      if (handled) {\n        console.clear();\n\n        data.assets.forEach(function (asset) {\n          hmrApply(global.parcelRequire, asset);\n        });\n\n        assetsToAccept.forEach(function (v) {\n          hmrAcceptRun(v[0], v[1]);\n        });\n      } else {\n        window.location.reload();\n      }\n    }\n\n    if (data.type === 'reload') {\n      ws.close();\n      ws.onclose = function () {\n        location.reload();\n      }\n    }\n\n    if (data.type === 'error-resolved') {\n      console.log('[parcel] ✨ Error resolved');\n\n      removeErrorOverlay();\n    }\n\n    if (data.type === 'error') {\n      console.error('[parcel] 🚨  ' + data.error.message + '\\n' + data.error.stack);\n\n      removeErrorOverlay();\n\n      var overlay = createErrorOverlay(data);\n      document.body.appendChild(overlay);\n    }\n  };\n}\n\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n  }\n}\n\nfunction createErrorOverlay(data) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n\n  // html encode message and stack trace\n  var message = document.createElement('div');\n  var stackTrace = document.createElement('pre');\n  message.innerText = data.error.message;\n  stackTrace.innerText = data.error.stack;\n\n  overlay.innerHTML = (\n    '<div style=\"background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;\">' +\n      '<span style=\"background: red; padding: 2px 4px; border-radius: 2px;\">ERROR</span>' +\n      '<span style=\"top: 2px; margin-left: 5px; position: relative;\">🚨</span>' +\n      '<div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">' + message.innerHTML + '</div>' +\n      '<pre>' + stackTrace.innerHTML + '</pre>' +\n    '</div>'\n  );\n\n  return overlay;\n\n}\n\nfunction getParents(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n\n  var parents = [];\n  var k, d, dep;\n\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || (Array.isArray(dep) && dep[dep.length - 1] === id)) {\n        parents.push(k);\n      }\n    }\n  }\n\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n\n  return parents;\n}\n\nfunction hmrApply(bundle, asset) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (modules[asset.id] || !bundle.parent) {\n    var fn = new Function('require', 'module', 'exports', asset.generated.js);\n    asset.isNew = !modules[asset.id];\n    modules[asset.id] = [fn, asset.deps];\n  } else if (bundle.parent) {\n    hmrApply(bundle.parent, asset);\n  }\n}\n\nfunction hmrAcceptCheck(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (!modules[id] && bundle.parent) {\n    return hmrAcceptCheck(bundle.parent, id);\n  }\n\n  if (checkedAssets[id]) {\n    return;\n  }\n  checkedAssets[id] = true;\n\n  var cached = bundle.cache[id];\n\n  assetsToAccept.push([bundle, id]);\n\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    return true;\n  }\n\n  return getParents(global.parcelRequire, id).some(function (id) {\n    return hmrAcceptCheck(global.parcelRequire, id)\n  });\n}\n\nfunction hmrAcceptRun(bundle, id) {\n  var cached = bundle.cache[id];\n  bundle.hotData = {};\n  if (cached) {\n    cached.hot.data = bundle.hotData;\n  }\n\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData);\n    });\n  }\n\n  delete bundle.cache[id];\n  bundle(id);\n\n  cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      cb();\n    });\n    return true;\n  }\n}\n"]}